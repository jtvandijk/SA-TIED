[
  {
    "objectID": "03-spatial-autocorrelation.html",
    "href": "03-spatial-autocorrelation.html",
    "title": "1 Spatial Autocorrelation",
    "section": "",
    "text": "Start your Geospatial-Workshop24 project and open a new script. Save this as 03-autocorrelation.r. We will start again by loading the libraries that we will need:\n\n\n\nR code\n\n# load libraries\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(tmap)\nlibrary(spdep)\n\n\n\n\n\nIn this session, we will be looking at education at the municipal level, focusing on the number of people with no schooling aggregated from the South African Census Community Profiles 2011. Along with this dataset, we also have access to a GeoPackage that contains the spatial boundaries of these municipalities. You can download both files below and save them in your project folder under data/attributes and data/spatial, respectively.\n\n\n\nFile\nType\nLink\n\n\n\n\nSA Census 2011 No Schooling Variable\ncsv\nDownload\n\n\nSA Municipalities\nGeoPackage\nDownload\n\n\n\n\n\n\n\n\n\nTo download the csv file containing the mn_no_school variable that is hosted on GitHub, click on the Download raw file button on the top right of your screen and it should download directly to your computer.\n\n\n\nOnce downloaded, we can load both files into memory:\n\n\n\nR code\n\n# load spatial data\nsa_municipality &lt;- st_read(\"data/spatial/municipality-south-africa-2013.gpkg\")\n\n\nReading layer `municipality-south-africa-2013' from data source \n  `/Users/justinvandijk/Library/CloudStorage/Dropbox/UCL/Web/jtvandijk.github.io/SA-TIED/data/spatial/municipality-south-africa-2013.gpkg' \n  using driver `GPKG'\nSimple feature collection with 234 features and 19 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 1831416 ymin: -4141363 xmax: 3667419 ymax: -2526543\nProjected CRS: WGS 84 / Pseudo-Mercator\n\n# load attribute data\nsa_no_schooling &lt;- read_csv(\"data/attributes/sa-no-schooling.csv\")\n\nRows: 234 Columns: 4\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): mn_name\ndbl (3): mn_code, mn_pop, mn_no_school\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\n\n\n\n\n\nYou can inspect both objects using the View() function.\n\n\n\n\n\n\nWith this dataset, we are interested in analysing the proportion of people without schooling across the country and visualising this information on a map. Let us start by preparing the data for mapping:\n\n\n\nR code\n\n# calculate proportions\nsa_no_schooling &lt;- sa_no_schooling |&gt;\n  mutate(mn_prop_no_schooling = mn_no_school / mn_pop)\n\n# join attribute data onto spatial data\nsa_municipality &lt;- sa_municipality |&gt; \n  left_join(sa_no_schooling, by = c(\"mn_code\" = \"mn_code\"))\n\n\nWe can now create a simple map:\n\n\n\nR code\n\n# shape, polygons\ntm_shape(sa_municipality) +\n  # specify column, classes\n  tm_polygons(\n    col = \"mn_prop_no_schooling\",\n    n = 5,\n    style = \"jenks\"\n  ) +\n\n  # no legend\n  tm_layout(\n    legend.show = FALSE\n  )\n\n\n\n\n\nFigure 1: Proportions of people having no schooling by municipality.\n\n\n\n\nLooking at the map, the geographical patterning of the percentage of the population that does not have any schooling appears to be neither random nor uniform, with a tendency for similar values to be found in closely located municipalities. Let us compare our map to a map with the same values which have been randomly permutated:\n\n\n\nR code\n\n# seed for reproducibility of random permutation\nset.seed(99)\n\n# random permutation\nsa_municipality &lt;- sa_municipality |&gt;\n  mutate(mn_prop_no_schooling_random = sample(sa_municipality$mn_prop_no_schooling, replace = FALSE))\n\n# shape, polygons\ntm_shape(sa_municipality) +\n  # specify column, classes\n  tm_polygons(\n    col = \"mn_prop_no_schooling_random\",\n    n = 5,\n    style = \"jenks\"\n  ) +\n\n  # no legend\n  tm_layout(\n    legend.show = FALSE\n  )\n\n\n\n\n\nFigure 2: Proportions of people having no schooling by municipality with randomly permutated values.\n\n\n\n\nLooking at Figure 2, even with the values being randomly permuted, certain patterns seem to emerge. This observation raises an important question: to what extent are the patterns that we see in the actual data actually present? A widely used method to quantify the similarity between neighbouring locations is by calculating Moran’s I statistic. This measure assesses spatial autocorrelation, indicating the degree to which values of a variable cluster spatially — either through similar (positive spatial autocorrelation) or contrasting values (negative spatial autocorrelation).\nUnderlying our Moran’s I test is the concept of a spatial lag. A spatial lag refers to a concept in spatial analysis where the value of a variable at a given location is influenced by the values of the same variable at neighboring locations. Essentially, it captures the idea that observations in close proximity are likely to be correlated, meaning that what happens in one area can ‘lag’ into or affect nearby areas. The Moran’s I statistic tries to capture the relationship between a value and its spatial lag. An Ordinary Least Squares (OLS) regression is applied, after both variables have been transformed to z-scores, to fit the data and produce a slope, which determines the Moran’s I statistic.\n\n\n\n\n\nFigure 3: Scatter plot of spatially lagged income (neighboring income) versus each areas income. Source: Manuel Gimond.\n\n\n\n\n\n\n\n\n\n\nMoran’s I values typically range from \\(-1\\) to \\(1\\):\n\n+1: Indicates perfect positive spatial autocorrelation. High values cluster near other high values, and low values near other low values.\n0: Suggests no spatial autocorrelation, meaning the spatial distribution of the variable is random.\n-1: Indicates perfect negative spatial autocorrelation. High values cluster near low values, and vice versa (a checkerboard pattern).\n\n\n\n\nThere are two approaches to estimating the significance of the Moran’s I statistic: an analytical method and a computational method. The analytical method relies on assumptions about the data, such as normality, which can sometimes limit its reliability. In contrast, the computational method, which is preferred here, does not make such assumptions and offers a more flexible and robust evaluation of significance.\nThe computational approach is based on a repeated random permutation of the observed values. The Moran’s I statistic is then calculated for each of these randomly reshuffled data sets, generating a reference distribution. By comparing the observed Moran’s I value to this reference distribution, we can assess whether our observed statistic is typical or an outlier and calculate a psuedo \\(p\\)-value (see Figure 4). If the observed Moran’s I value is an outlier, meaning it falls outside the range expected from random data distribution, it suggests a significant degree of clustering in the data.\n\n\n\n\n\nFigure 4: Determining significance using a Monte Carlo simulation. Source: Manuel Gimond.\n\n\n\n\nWe can derive a pseudo-\\(p\\) value from these simulation results as follows:\n\\[\n\\frac{N_{extreme} + 1}{N + 1}\n\\]\nwhere \\({N_{extreme}}\\) is the number of simulated Moran’s I values that were more extreme than our observed statistic and \\({N}\\) is the total number of simulations. In the example shown in Figure 4, only 1 out the 199 simulations was more extreme than the observed local Moran’s I statistic. Therefore \\({N_{extreme}}\\) = 1 , so \\(p\\) is equal to \\((1+1) / (199 + 1) = 0.01\\). This means that there is a one percent probability that we would be wrong in rejecting the null hypothesis of spatial randomness.\n\n\n\nIf the purpose of a Moran’s I test is to quantify how similar places are to their neighbours, the first step is to define what constitutes a neighbour. This definition is not necessarily straightforward, because ‘neighbouring’ observations can be determined in various ways, based on either geometry or proximity. The most common methods include:\n\nContiguity: Spatial units are considered neighbours if their polygon boundaries touch.\nFixed Distance: Spatial units are considered neighbours if they fall within a specified distance.\n\\(k\\) Nearest Neighbours: Spatial units are considered neighbours if they are among the closest neighbours.\n\nTo capture this information, we need to formalise the spatial relationships within our data by constructing a spatial weights matrix (\\(W_{ij}\\)). This matrix defines which units are neighbours based on our chosen criteria.\n\n\n\n\n\n\nIn the following example, neighbours are defined as places that share a border (i.e., they are contiguous). Currently, it is sufficient for them to meet at a single point — so if two places are triangular, touching corners would count them as neighbours. If, however, you require them to share an edge, rather than just a corner, you can modify the default argument by setting queen = FALSE.\n\n\n\n\n\n\nR code\n\n# create neighbour list\nsa_mn_nb &lt;- poly2nb(sa_municipality, queen = TRUE)\n\n# inspect\nsummary(sa_mn_nb)\n\n\nNeighbour list object:\nNumber of regions: 234 \nNumber of nonzero links: 1244 \nPercentage nonzero weights: 2.271897 \nAverage number of links: 5.316239 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 10 \n 1  7 22 35 56 64 40  3  5  1 \n1 least connected region:\n102 with 1 link\n1 most connected region:\n193 with 10 links\n\n\nThe neighbour list object is a sparse matrix that lists the neighboring polygons for each municipality. This matrix represents the spatial relationships between municipalities, where each entry indicates which polygons share boundaries. These neighborhood relationships can be visualised as a graph by extracting the coordinate points of the centroids of the polygons representing each municipality:\n\n\n\n\n\n\nRegardless of the neighborhood definition you choose, it is important to verify the results, particularly when using contiguity-based approaches. If your spatial file has issues such as polygons that appear adjacent but do not actually share a border, your results may be inaccurate. You could increase the default value of the snap distance parameter in the poly2nb() function to include these polygons only separated by small gaps.\n\n\n\n\n\n\nR code\n\n# extract centroids from polygons\nsa_mn_cent &lt;- st_centroid(sa_municipality, of_largest_polygon = TRUE)\n\n\nWarning: st_centroid assumes attributes are constant over geometries\n\n# plot graph\npar(mai = c(0, 0, 0, 0))\nplot(st_geometry(sa_municipality), border = \"#cccccc\")\nplot(sa_mn_nb, st_geometry(sa_mn_cent), add = T)\n\n\n\n\nFigure 5: Neighbourhood graph using queen contiguity.\n\n\n\n\n\n\n\nThe neighbourhood list simply identifies which areas (polygons) are neighbours, but spatial weights take this a step further by assigning a weight to each neighbourhood connection. This is important because not all polygons have the same number of neighbours. To ensure that our spatially lagged values are comparable across neighbourhoods of different sizes, standardisation is required. The code below uses style = 'W' to row-standardise the values: if a municipality has five neighbours, the value of the spatially lagged variable will be the average of that variable across those five neighbours, with each neighbour receiving equal weight.\n\n\n\nR code\n\n# create spatial weights matrix\nsa_mn_nb_weights &lt;- sa_mn_nb |&gt;\n    nb2listw(style = \"W\")\n\n# inspect - neigbhours of polygon '10'\nsa_mn_nb_weights$neighbours[[10]]\n\n\n[1]   3   9  11  44  45 124 165\n\n# inspect - weights of neighbours of polygon '10'\nsa_mn_nb_weights$weights[[10]]\n\n[1] 0.1428571 0.1428571 0.1428571 0.1428571 0.1428571 0.1428571 0.1428571\n\n\n\n\n\n\n\n\nNot all places have neighbours. Islands, by definition, will not be considered as neighbours using a contiguity approach. If you attempt to create spatial weights using the nb2listw() function with a neighbourhood list that includes places without neighbours, you will encounter an error message. Potential solutions include using a different neighbourhood definition (e.g. \\(k\\)-nearest neighbours) or manually editing the neighbourhood file if you wish to include these polygons. Alternatively, you can leave it as is but then you must specify the argument zero.policy = TRUE in nb2listw() to allow for empty sets.\n\n\n\n\n\n\nNow that everything is in place, we can begin by plotting the proportion of people without schooling against the spatially lagged values:\n\n\n\nR code\n\n# moran's plot\nmoran.plot(sa_municipality$mn_prop_no_schooling, listw = sa_mn_nb_weights)\n\n\n\n\n\nFigure 6: Plot of lagged values versus polygon values.\n\n\n\n\nWe observe a positive relationship between our mn_prop_no_schooling variable and the spatially lagged values, suggesting that our global Moran’s I test will likely yield a statistic reflective of the slope visible in the scatter plot.\n\n\n\nR code\n\n# moran's test\nmoran &lt;- moran.mc(sa_municipality$mn_prop_no_schooling, listw = sa_mn_nb_weights,\n    nsim = 999)\n\n# results\nmoran\n\n\n\n    Monte-Carlo simulation of Moran I\n\ndata:  sa_municipality$mn_prop_no_schooling \nweights: sa_mn_nb_weights  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.52666, observed rank = 1000, p-value = 0.001\nalternative hypothesis: greater\n\n\nThe results of the Monte Carlo simulation, visualised in Figure 7, suggest that there is statistically significant positive autocorrelation in our variable. This indicates that municipalities with higher percentages of people without schooling tend to be surrounded by other municipalities with similarly high percentages. Likewise, municipalities with lower percentages of people without schooling are generally surrounded by municipalities with similarly low values.\n\n\n\nR code\n\n# permutation distribution\nplot(moran, main = \"\")\n\n\n\n\n\nFigure 7: Density plot of permutation outcomes.\n\n\n\n\n\n\n\nAlthough we have established that there is positive spatial autocorrelation in our data, we still need to identify the specific spatial patterns. Looking back at Figure 3, you will notice that the plot is divided into four quadrants.\n\nTop-right quadrant: This area represents municipalities that have a higher-than-average share of the population without schooling and are surrounded by other municipalities with similarly high shares of the population without schooling. These are known as high-high clusters.\nBottom-left quadrant: This area represents municipalities with a lower-than-average share of the population without schooling, surrounded by other municipalities with similarly low shares. These are low-low clusters.\nTop-left quadrant: Municipalities with a higher-than-average share of the population without schooling surrounded by municipalities with a lower-than-average share. These are high-low clusters.\nBottom-right quadrant: Municipalities with a lower-than-average share of the population without schooling surrounded by municipalities with a higher-than-average share. These are low-high clusters.\n\nWe can show these area on a map by deconstructing the Moran’s I into a series of local Moran values, each measuring how similar each place is (individually) to its neighbours.\n\n\n\nR code\n\n# local moran's test\nlmoran &lt;- localmoran_perm(sa_municipality$mn_prop_no_schooling, listw = sa_mn_nb_weights,\n    nsim = 999)\n\n# results\nhead(lmoran)\n\n\n            Ii          E.Ii       Var.Ii       Z.Ii Pr(z != E(Ii))\n1 -0.050379105 -5.007116e-04 0.0055169108 -0.6715285      0.5018839\n2  0.076088895  8.806626e-03 0.0358989035  0.3551077      0.7225089\n3  0.294045408 -6.371539e-04 0.1058262803  0.9058529      0.3650137\n4  0.452492637  4.444755e-03 0.4386494317  0.6764966      0.4987254\n5  0.111902772 -1.280624e-03 0.0195226887  0.8100520      0.4179103\n6  0.002486432  9.338536e-05 0.0005451827  0.1024897      0.9183680\n  Pr(z != E(Ii)) Sim Pr(folded) Sim   Skewness    Kurtosis\n1              0.506          0.253 -0.1147855 -0.23093560\n2              0.714          0.357  0.1969864  0.03091263\n3              0.356          0.178  0.2355106  0.06633588\n4              0.502          0.251  0.1855721 -0.35342466\n5              0.438          0.219  0.1767742 -0.31332065\n6              0.948          0.474 -0.1729386 -0.13325485\n\n\nWe are not given a single statistic as we did with our global Moran’s I, but rather we get a table of different statistics that are all related back to each of the municipalities in our dataset. If we refer to the help page for the localmoran() function, we can find detailed explanations of these statistics. The most relevant ones include:\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nIi\nLocal Moran’s I statistic.\n\n\nE.Ii\nExpectation (mean) of the local Moran’s I statistic.\n\n\nVar.Ii\nVariance of local Moran’s I statistic\n\n\nZ.Ii\nStandard deviation (z-score) of the local Moran’s I statistic.\n\n\nPr()\nPseudo \\(p\\)-value of local Moran’s I statistic based on standard deviations and means from the permutation sample.\n\n\nPr() Sim\nPseudo \\(p\\)-value of local Moran’s I statistic based on the rank within the permutation sample, assuming a uniform distribution.\n\n\nPr(Folded) Sim\nPseudo \\(p\\)-value of local Moran’s I statistic based on the rank within the permutation sample using a one-sided test, assuming a uniform distribution.\n\n\n\nWe can further extract the quadrants to which of all these polygons have been assigned:\n\n\n\nR code\n\n# extract quadrants\nlmoran_quadrants &lt;- attr(lmoran, \"quadr\")\n\n# inspect\nhead(lmoran_quadrants)\n\n\n\n\n\n\nmean\nmedian\npysal\n\n\n\n\nLow-High\nLow-High\nLow-High\n\n\nHigh-High\nHigh-High\nHigh-High\n\n\nHigh-High\nHigh-High\nHigh-High\n\n\nHigh-High\nHigh-High\nHigh-High\n\n\nHigh-High\nHigh-High\nHigh-High\n\n\nLow-Low\nLow-Low\nLow-Low\n\n\n\n\n\n\nWe can now link these values back to our spatial dataframe and make a map using the tmap library:\n\n\n\nR code\n\n# replace names\nnames(lmoran_quadrants) &lt;- c(\"lmoran_mean\", \"lmoran_median\", \"lmoran_pysal\")\n\n# bind results\nsa_municipality &lt;- sa_municipality |&gt;\n  cbind(lmoran_quadrants)\n\n# shape, polygons\ntm_shape(sa_municipality) +\n\n  # specify column, colours\n  tm_polygons(\n    col = \"lmoran_mean\",\n    border.col = \"#ffffff\",\n    border.alpha = 0.3,\n    palette = c(\n      \"Low-Low\" = \"#0571b0\",\n      \"Low-High\" = \"#92c5de\",\n      \"High-Low\" = \"#f4a582\",\n      \"High-High\" = \"#ca0020\"\n    ),\n    title = \"Cluster type\",\n  ) +\n\n  # set layout\n  tm_layout(\n    legend.outside = FALSE,\n    legend.position = c(\"left\", \"top\"),\n  )\n\n\n\n\n\nFigure 8: Mapping the Local Moran’s I clusters.\n\n\n\n\nThis type of map is called a LISA map and is a great way of showing how a variable is actually clustering over space. However, we can improve on this further by only mapping the statistically significant clusters:\n\n\n\nR code\n\n# replace values if not significant\nlmoran_quadrants[lmoran[, 6] &gt; 0.05, ] &lt;- NA\n\n# replace names\nnames(lmoran_quadrants) &lt;- c(\"lmoran_mean_sig\", \"lmoran_median_sig\", \"lmoran_pysal_sig\")\n\n# bind results\nsa_municipality &lt;- sa_municipality |&gt;\n  cbind(lmoran_quadrants)\n\n# shape, polygons\ntm_shape(sa_municipality) +\n\n  # specify column, colours\n  tm_polygons(\n    col = \"lmoran_mean_sig\",\n    border.col = \"#ffffff\",\n    border.alpha = 0.3,\n    palette = c(\n      \"Low-Low\" = \"#0571b0\",\n      \"Low-High\" = \"#92c5de\",\n      \"High-Low\" = \"#f4a582\",\n      \"High-High\" = \"#ca0020\"\n    ),\n    title = \"Cluster type\",\n  ) +\n\n  # set layout\n  tm_layout(\n    legend.outside = FALSE,\n    legend.position = c(\"left\", \"top\"),\n  )\n\n\n\n\n\nFigure 9: Mapping the significant Local Moran’s I clusters.\n\n\n\n\n\n\n\n\n\n\nThis new map may still not fully address the issue of statistical significance due to repeated testing, and some values may appear significant purely by chance. To correct for this, you can adjust the \\(p\\)-values using R’s p.adjust() function. For further details, refer to Manual Gimond’s explanation of the multiple comparison problem in the context of the pseudo-\\(p\\) values.\n\n\n\n\n\n\nThis concludes this session. Any statistic that includes spatial weights is dependent upon how those weights are defined. We have so far used first order contiguity, i.e. polygons that share a boundary, but there is no particular reason why we should not include second order contiguity polygons (i.e. neighbours of neighbours), use a fixed distance neighbours definitions, or adopt a \\(k\\) nearest neighbours definition.\nPlease try to complete the following tasks:\n\nExtract the centroids from the sa_municipality file.\nIdentify the 5 nearest neighbours for each municipalities, using the knearneigh() function.\nCreate a neigbhour list of these nearest neighbours, using the knn2nb() function.\nCompute the Global Moran’s I of the mn_prop_no_schooling variable using this new neighbourhood definition.\nMap the statistically significant clusters of Local Moran’s I based on this new neighbourhood definition."
  },
  {
    "objectID": "03-spatial-autocorrelation.html#loading-spatial-data",
    "href": "03-spatial-autocorrelation.html#loading-spatial-data",
    "title": "1 Spatial Autocorrelation",
    "section": "",
    "text": "Start your Geospatial-Workshop24 project and open a new script. Save this as 03-autocorrelation.r. We will start again by loading the libraries that we will need:\n\n\n\nR code\n\n# load libraries\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(tmap)\nlibrary(spdep)\n\n\n\n\n\nIn this session, we will be looking at education at the municipal level, focusing on the number of people with no schooling aggregated from the South African Census Community Profiles 2011. Along with this dataset, we also have access to a GeoPackage that contains the spatial boundaries of these municipalities. You can download both files below and save them in your project folder under data/attributes and data/spatial, respectively.\n\n\n\nFile\nType\nLink\n\n\n\n\nSA Census 2011 No Schooling Variable\ncsv\nDownload\n\n\nSA Municipalities\nGeoPackage\nDownload\n\n\n\n\n\n\n\n\n\nTo download the csv file containing the mn_no_school variable that is hosted on GitHub, click on the Download raw file button on the top right of your screen and it should download directly to your computer.\n\n\n\nOnce downloaded, we can load both files into memory:\n\n\n\nR code\n\n# load spatial data\nsa_municipality &lt;- st_read(\"data/spatial/municipality-south-africa-2013.gpkg\")\n\n\nReading layer `municipality-south-africa-2013' from data source \n  `/Users/justinvandijk/Library/CloudStorage/Dropbox/UCL/Web/jtvandijk.github.io/SA-TIED/data/spatial/municipality-south-africa-2013.gpkg' \n  using driver `GPKG'\nSimple feature collection with 234 features and 19 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 1831416 ymin: -4141363 xmax: 3667419 ymax: -2526543\nProjected CRS: WGS 84 / Pseudo-Mercator\n\n# load attribute data\nsa_no_schooling &lt;- read_csv(\"data/attributes/sa-no-schooling.csv\")\n\nRows: 234 Columns: 4\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): mn_name\ndbl (3): mn_code, mn_pop, mn_no_school\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\n\n\n\n\n\nYou can inspect both objects using the View() function."
  },
  {
    "objectID": "03-spatial-autocorrelation.html#spatial-dependency",
    "href": "03-spatial-autocorrelation.html#spatial-dependency",
    "title": "1 Spatial Autocorrelation",
    "section": "",
    "text": "With this dataset, we are interested in analysing the proportion of people without schooling across the country and visualising this information on a map. Let us start by preparing the data for mapping:\n\n\n\nR code\n\n# calculate proportions\nsa_no_schooling &lt;- sa_no_schooling |&gt;\n  mutate(mn_prop_no_schooling = mn_no_school / mn_pop)\n\n# join attribute data onto spatial data\nsa_municipality &lt;- sa_municipality |&gt; \n  left_join(sa_no_schooling, by = c(\"mn_code\" = \"mn_code\"))\n\n\nWe can now create a simple map:\n\n\n\nR code\n\n# shape, polygons\ntm_shape(sa_municipality) +\n  # specify column, classes\n  tm_polygons(\n    col = \"mn_prop_no_schooling\",\n    n = 5,\n    style = \"jenks\"\n  ) +\n\n  # no legend\n  tm_layout(\n    legend.show = FALSE\n  )\n\n\n\n\n\nFigure 1: Proportions of people having no schooling by municipality.\n\n\n\n\nLooking at the map, the geographical patterning of the percentage of the population that does not have any schooling appears to be neither random nor uniform, with a tendency for similar values to be found in closely located municipalities. Let us compare our map to a map with the same values which have been randomly permutated:\n\n\n\nR code\n\n# seed for reproducibility of random permutation\nset.seed(99)\n\n# random permutation\nsa_municipality &lt;- sa_municipality |&gt;\n  mutate(mn_prop_no_schooling_random = sample(sa_municipality$mn_prop_no_schooling, replace = FALSE))\n\n# shape, polygons\ntm_shape(sa_municipality) +\n  # specify column, classes\n  tm_polygons(\n    col = \"mn_prop_no_schooling_random\",\n    n = 5,\n    style = \"jenks\"\n  ) +\n\n  # no legend\n  tm_layout(\n    legend.show = FALSE\n  )\n\n\n\n\n\nFigure 2: Proportions of people having no schooling by municipality with randomly permutated values.\n\n\n\n\nLooking at Figure 2, even with the values being randomly permuted, certain patterns seem to emerge. This observation raises an important question: to what extent are the patterns that we see in the actual data actually present? A widely used method to quantify the similarity between neighbouring locations is by calculating Moran’s I statistic. This measure assesses spatial autocorrelation, indicating the degree to which values of a variable cluster spatially — either through similar (positive spatial autocorrelation) or contrasting values (negative spatial autocorrelation).\nUnderlying our Moran’s I test is the concept of a spatial lag. A spatial lag refers to a concept in spatial analysis where the value of a variable at a given location is influenced by the values of the same variable at neighboring locations. Essentially, it captures the idea that observations in close proximity are likely to be correlated, meaning that what happens in one area can ‘lag’ into or affect nearby areas. The Moran’s I statistic tries to capture the relationship between a value and its spatial lag. An Ordinary Least Squares (OLS) regression is applied, after both variables have been transformed to z-scores, to fit the data and produce a slope, which determines the Moran’s I statistic.\n\n\n\n\n\nFigure 3: Scatter plot of spatially lagged income (neighboring income) versus each areas income. Source: Manuel Gimond.\n\n\n\n\n\n\n\n\n\n\nMoran’s I values typically range from \\(-1\\) to \\(1\\):\n\n+1: Indicates perfect positive spatial autocorrelation. High values cluster near other high values, and low values near other low values.\n0: Suggests no spatial autocorrelation, meaning the spatial distribution of the variable is random.\n-1: Indicates perfect negative spatial autocorrelation. High values cluster near low values, and vice versa (a checkerboard pattern).\n\n\n\n\nThere are two approaches to estimating the significance of the Moran’s I statistic: an analytical method and a computational method. The analytical method relies on assumptions about the data, such as normality, which can sometimes limit its reliability. In contrast, the computational method, which is preferred here, does not make such assumptions and offers a more flexible and robust evaluation of significance.\nThe computational approach is based on a repeated random permutation of the observed values. The Moran’s I statistic is then calculated for each of these randomly reshuffled data sets, generating a reference distribution. By comparing the observed Moran’s I value to this reference distribution, we can assess whether our observed statistic is typical or an outlier and calculate a psuedo \\(p\\)-value (see Figure 4). If the observed Moran’s I value is an outlier, meaning it falls outside the range expected from random data distribution, it suggests a significant degree of clustering in the data.\n\n\n\n\n\nFigure 4: Determining significance using a Monte Carlo simulation. Source: Manuel Gimond.\n\n\n\n\nWe can derive a pseudo-\\(p\\) value from these simulation results as follows:\n\\[\n\\frac{N_{extreme} + 1}{N + 1}\n\\]\nwhere \\({N_{extreme}}\\) is the number of simulated Moran’s I values that were more extreme than our observed statistic and \\({N}\\) is the total number of simulations. In the example shown in Figure 4, only 1 out the 199 simulations was more extreme than the observed local Moran’s I statistic. Therefore \\({N_{extreme}}\\) = 1 , so \\(p\\) is equal to \\((1+1) / (199 + 1) = 0.01\\). This means that there is a one percent probability that we would be wrong in rejecting the null hypothesis of spatial randomness."
  },
  {
    "objectID": "03-spatial-autocorrelation.html#defining-neighbours",
    "href": "03-spatial-autocorrelation.html#defining-neighbours",
    "title": "1 Spatial Autocorrelation",
    "section": "",
    "text": "If the purpose of a Moran’s I test is to quantify how similar places are to their neighbours, the first step is to define what constitutes a neighbour. This definition is not necessarily straightforward, because ‘neighbouring’ observations can be determined in various ways, based on either geometry or proximity. The most common methods include:\n\nContiguity: Spatial units are considered neighbours if their polygon boundaries touch.\nFixed Distance: Spatial units are considered neighbours if they fall within a specified distance.\n\\(k\\) Nearest Neighbours: Spatial units are considered neighbours if they are among the closest neighbours.\n\nTo capture this information, we need to formalise the spatial relationships within our data by constructing a spatial weights matrix (\\(W_{ij}\\)). This matrix defines which units are neighbours based on our chosen criteria.\n\n\n\n\n\n\nIn the following example, neighbours are defined as places that share a border (i.e., they are contiguous). Currently, it is sufficient for them to meet at a single point — so if two places are triangular, touching corners would count them as neighbours. If, however, you require them to share an edge, rather than just a corner, you can modify the default argument by setting queen = FALSE.\n\n\n\n\n\n\nR code\n\n# create neighbour list\nsa_mn_nb &lt;- poly2nb(sa_municipality, queen = TRUE)\n\n# inspect\nsummary(sa_mn_nb)\n\n\nNeighbour list object:\nNumber of regions: 234 \nNumber of nonzero links: 1244 \nPercentage nonzero weights: 2.271897 \nAverage number of links: 5.316239 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 10 \n 1  7 22 35 56 64 40  3  5  1 \n1 least connected region:\n102 with 1 link\n1 most connected region:\n193 with 10 links\n\n\nThe neighbour list object is a sparse matrix that lists the neighboring polygons for each municipality. This matrix represents the spatial relationships between municipalities, where each entry indicates which polygons share boundaries. These neighborhood relationships can be visualised as a graph by extracting the coordinate points of the centroids of the polygons representing each municipality:\n\n\n\n\n\n\nRegardless of the neighborhood definition you choose, it is important to verify the results, particularly when using contiguity-based approaches. If your spatial file has issues such as polygons that appear adjacent but do not actually share a border, your results may be inaccurate. You could increase the default value of the snap distance parameter in the poly2nb() function to include these polygons only separated by small gaps.\n\n\n\n\n\n\nR code\n\n# extract centroids from polygons\nsa_mn_cent &lt;- st_centroid(sa_municipality, of_largest_polygon = TRUE)\n\n\nWarning: st_centroid assumes attributes are constant over geometries\n\n# plot graph\npar(mai = c(0, 0, 0, 0))\nplot(st_geometry(sa_municipality), border = \"#cccccc\")\nplot(sa_mn_nb, st_geometry(sa_mn_cent), add = T)\n\n\n\n\nFigure 5: Neighbourhood graph using queen contiguity."
  },
  {
    "objectID": "03-spatial-autocorrelation.html#defining-weights",
    "href": "03-spatial-autocorrelation.html#defining-weights",
    "title": "1 Spatial Autocorrelation",
    "section": "",
    "text": "The neighbourhood list simply identifies which areas (polygons) are neighbours, but spatial weights take this a step further by assigning a weight to each neighbourhood connection. This is important because not all polygons have the same number of neighbours. To ensure that our spatially lagged values are comparable across neighbourhoods of different sizes, standardisation is required. The code below uses style = 'W' to row-standardise the values: if a municipality has five neighbours, the value of the spatially lagged variable will be the average of that variable across those five neighbours, with each neighbour receiving equal weight.\n\n\n\nR code\n\n# create spatial weights matrix\nsa_mn_nb_weights &lt;- sa_mn_nb |&gt;\n    nb2listw(style = \"W\")\n\n# inspect - neigbhours of polygon '10'\nsa_mn_nb_weights$neighbours[[10]]\n\n\n[1]   3   9  11  44  45 124 165\n\n# inspect - weights of neighbours of polygon '10'\nsa_mn_nb_weights$weights[[10]]\n\n[1] 0.1428571 0.1428571 0.1428571 0.1428571 0.1428571 0.1428571 0.1428571\n\n\n\n\n\n\n\n\nNot all places have neighbours. Islands, by definition, will not be considered as neighbours using a contiguity approach. If you attempt to create spatial weights using the nb2listw() function with a neighbourhood list that includes places without neighbours, you will encounter an error message. Potential solutions include using a different neighbourhood definition (e.g. \\(k\\)-nearest neighbours) or manually editing the neighbourhood file if you wish to include these polygons. Alternatively, you can leave it as is but then you must specify the argument zero.policy = TRUE in nb2listw() to allow for empty sets."
  },
  {
    "objectID": "03-spatial-autocorrelation.html#global-morans-i",
    "href": "03-spatial-autocorrelation.html#global-morans-i",
    "title": "1 Spatial Autocorrelation",
    "section": "",
    "text": "Now that everything is in place, we can begin by plotting the proportion of people without schooling against the spatially lagged values:\n\n\n\nR code\n\n# moran's plot\nmoran.plot(sa_municipality$mn_prop_no_schooling, listw = sa_mn_nb_weights)\n\n\n\n\n\nFigure 6: Plot of lagged values versus polygon values.\n\n\n\n\nWe observe a positive relationship between our mn_prop_no_schooling variable and the spatially lagged values, suggesting that our global Moran’s I test will likely yield a statistic reflective of the slope visible in the scatter plot.\n\n\n\nR code\n\n# moran's test\nmoran &lt;- moran.mc(sa_municipality$mn_prop_no_schooling, listw = sa_mn_nb_weights,\n    nsim = 999)\n\n# results\nmoran\n\n\n\n    Monte-Carlo simulation of Moran I\n\ndata:  sa_municipality$mn_prop_no_schooling \nweights: sa_mn_nb_weights  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.52666, observed rank = 1000, p-value = 0.001\nalternative hypothesis: greater\n\n\nThe results of the Monte Carlo simulation, visualised in Figure 7, suggest that there is statistically significant positive autocorrelation in our variable. This indicates that municipalities with higher percentages of people without schooling tend to be surrounded by other municipalities with similarly high percentages. Likewise, municipalities with lower percentages of people without schooling are generally surrounded by municipalities with similarly low values.\n\n\n\nR code\n\n# permutation distribution\nplot(moran, main = \"\")\n\n\n\n\n\nFigure 7: Density plot of permutation outcomes."
  },
  {
    "objectID": "03-spatial-autocorrelation.html#local-morans-i",
    "href": "03-spatial-autocorrelation.html#local-morans-i",
    "title": "1 Spatial Autocorrelation",
    "section": "",
    "text": "Although we have established that there is positive spatial autocorrelation in our data, we still need to identify the specific spatial patterns. Looking back at Figure 3, you will notice that the plot is divided into four quadrants.\n\nTop-right quadrant: This area represents municipalities that have a higher-than-average share of the population without schooling and are surrounded by other municipalities with similarly high shares of the population without schooling. These are known as high-high clusters.\nBottom-left quadrant: This area represents municipalities with a lower-than-average share of the population without schooling, surrounded by other municipalities with similarly low shares. These are low-low clusters.\nTop-left quadrant: Municipalities with a higher-than-average share of the population without schooling surrounded by municipalities with a lower-than-average share. These are high-low clusters.\nBottom-right quadrant: Municipalities with a lower-than-average share of the population without schooling surrounded by municipalities with a higher-than-average share. These are low-high clusters.\n\nWe can show these area on a map by deconstructing the Moran’s I into a series of local Moran values, each measuring how similar each place is (individually) to its neighbours.\n\n\n\nR code\n\n# local moran's test\nlmoran &lt;- localmoran_perm(sa_municipality$mn_prop_no_schooling, listw = sa_mn_nb_weights,\n    nsim = 999)\n\n# results\nhead(lmoran)\n\n\n            Ii          E.Ii       Var.Ii       Z.Ii Pr(z != E(Ii))\n1 -0.050379105 -5.007116e-04 0.0055169108 -0.6715285      0.5018839\n2  0.076088895  8.806626e-03 0.0358989035  0.3551077      0.7225089\n3  0.294045408 -6.371539e-04 0.1058262803  0.9058529      0.3650137\n4  0.452492637  4.444755e-03 0.4386494317  0.6764966      0.4987254\n5  0.111902772 -1.280624e-03 0.0195226887  0.8100520      0.4179103\n6  0.002486432  9.338536e-05 0.0005451827  0.1024897      0.9183680\n  Pr(z != E(Ii)) Sim Pr(folded) Sim   Skewness    Kurtosis\n1              0.506          0.253 -0.1147855 -0.23093560\n2              0.714          0.357  0.1969864  0.03091263\n3              0.356          0.178  0.2355106  0.06633588\n4              0.502          0.251  0.1855721 -0.35342466\n5              0.438          0.219  0.1767742 -0.31332065\n6              0.948          0.474 -0.1729386 -0.13325485\n\n\nWe are not given a single statistic as we did with our global Moran’s I, but rather we get a table of different statistics that are all related back to each of the municipalities in our dataset. If we refer to the help page for the localmoran() function, we can find detailed explanations of these statistics. The most relevant ones include:\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nIi\nLocal Moran’s I statistic.\n\n\nE.Ii\nExpectation (mean) of the local Moran’s I statistic.\n\n\nVar.Ii\nVariance of local Moran’s I statistic\n\n\nZ.Ii\nStandard deviation (z-score) of the local Moran’s I statistic.\n\n\nPr()\nPseudo \\(p\\)-value of local Moran’s I statistic based on standard deviations and means from the permutation sample.\n\n\nPr() Sim\nPseudo \\(p\\)-value of local Moran’s I statistic based on the rank within the permutation sample, assuming a uniform distribution.\n\n\nPr(Folded) Sim\nPseudo \\(p\\)-value of local Moran’s I statistic based on the rank within the permutation sample using a one-sided test, assuming a uniform distribution.\n\n\n\nWe can further extract the quadrants to which of all these polygons have been assigned:\n\n\n\nR code\n\n# extract quadrants\nlmoran_quadrants &lt;- attr(lmoran, \"quadr\")\n\n# inspect\nhead(lmoran_quadrants)\n\n\n\n\n\n\nmean\nmedian\npysal\n\n\n\n\nLow-High\nLow-High\nLow-High\n\n\nHigh-High\nHigh-High\nHigh-High\n\n\nHigh-High\nHigh-High\nHigh-High\n\n\nHigh-High\nHigh-High\nHigh-High\n\n\nHigh-High\nHigh-High\nHigh-High\n\n\nLow-Low\nLow-Low\nLow-Low\n\n\n\n\n\n\nWe can now link these values back to our spatial dataframe and make a map using the tmap library:\n\n\n\nR code\n\n# replace names\nnames(lmoran_quadrants) &lt;- c(\"lmoran_mean\", \"lmoran_median\", \"lmoran_pysal\")\n\n# bind results\nsa_municipality &lt;- sa_municipality |&gt;\n  cbind(lmoran_quadrants)\n\n# shape, polygons\ntm_shape(sa_municipality) +\n\n  # specify column, colours\n  tm_polygons(\n    col = \"lmoran_mean\",\n    border.col = \"#ffffff\",\n    border.alpha = 0.3,\n    palette = c(\n      \"Low-Low\" = \"#0571b0\",\n      \"Low-High\" = \"#92c5de\",\n      \"High-Low\" = \"#f4a582\",\n      \"High-High\" = \"#ca0020\"\n    ),\n    title = \"Cluster type\",\n  ) +\n\n  # set layout\n  tm_layout(\n    legend.outside = FALSE,\n    legend.position = c(\"left\", \"top\"),\n  )\n\n\n\n\n\nFigure 8: Mapping the Local Moran’s I clusters.\n\n\n\n\nThis type of map is called a LISA map and is a great way of showing how a variable is actually clustering over space. However, we can improve on this further by only mapping the statistically significant clusters:\n\n\n\nR code\n\n# replace values if not significant\nlmoran_quadrants[lmoran[, 6] &gt; 0.05, ] &lt;- NA\n\n# replace names\nnames(lmoran_quadrants) &lt;- c(\"lmoran_mean_sig\", \"lmoran_median_sig\", \"lmoran_pysal_sig\")\n\n# bind results\nsa_municipality &lt;- sa_municipality |&gt;\n  cbind(lmoran_quadrants)\n\n# shape, polygons\ntm_shape(sa_municipality) +\n\n  # specify column, colours\n  tm_polygons(\n    col = \"lmoran_mean_sig\",\n    border.col = \"#ffffff\",\n    border.alpha = 0.3,\n    palette = c(\n      \"Low-Low\" = \"#0571b0\",\n      \"Low-High\" = \"#92c5de\",\n      \"High-Low\" = \"#f4a582\",\n      \"High-High\" = \"#ca0020\"\n    ),\n    title = \"Cluster type\",\n  ) +\n\n  # set layout\n  tm_layout(\n    legend.outside = FALSE,\n    legend.position = c(\"left\", \"top\"),\n  )\n\n\n\n\n\nFigure 9: Mapping the significant Local Moran’s I clusters.\n\n\n\n\n\n\n\n\n\n\nThis new map may still not fully address the issue of statistical significance due to repeated testing, and some values may appear significant purely by chance. To correct for this, you can adjust the \\(p\\)-values using R’s p.adjust() function. For further details, refer to Manual Gimond’s explanation of the multiple comparison problem in the context of the pseudo-\\(p\\) values."
  },
  {
    "objectID": "03-spatial-autocorrelation.html#autocorrelation",
    "href": "03-spatial-autocorrelation.html#autocorrelation",
    "title": "1 Spatial Autocorrelation",
    "section": "",
    "text": "This concludes this session. Any statistic that includes spatial weights is dependent upon how those weights are defined. We have so far used first order contiguity, i.e. polygons that share a boundary, but there is no particular reason why we should not include second order contiguity polygons (i.e. neighbours of neighbours), use a fixed distance neighbours definitions, or adopt a \\(k\\) nearest neighbours definition.\nPlease try to complete the following tasks:\n\nExtract the centroids from the sa_municipality file.\nIdentify the 5 nearest neighbours for each municipalities, using the knearneigh() function.\nCreate a neigbhour list of these nearest neighbours, using the knn2nb() function.\nCompute the Global Moran’s I of the mn_prop_no_schooling variable using this new neighbourhood definition.\nMap the statistically significant clusters of Local Moran’s I based on this new neighbourhood definition."
  }
]
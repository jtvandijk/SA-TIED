[
  {
    "objectID": "00-index.html",
    "href": "00-index.html",
    "title": "SA-TIED Geospatial Workshop",
    "section": "",
    "text": "Welcome to the workbook for the SA-TIED Geospatial Workshop. Over the course of this two-day introductory workshop, you will be introduced to the R programming language, learn how to map socio-economic and demographic data, and gain an understanding of the ideas behind spatial models. We will explore the following topics:\n\nFundamentals of using R for data analysis with the tidyverse library\nCreating basic maps using R using the tmap library\nQuantifying the degree of spatial dependence in a dataset\nIncorporating space into statistical models\n\n\n\n\nWhile there are no specific prerequisites for this workshop, basic familiarity with R, Python or Stata do-files is recommended. You will require a computer with admin rights to install the necessary software.\n\n\n\nThe schedule of this workshop is as follows:\n\n\n\nDay\nType\nTime\nDetails\n\n\n\n\n1\nLecture\n09h00-09h45\nSlides: R for Data Analysis\n\n\n1\nComputer tutorial\n10h00-12h00\nR for Data Analysis\n\n\n1\nLecture\n13h00-13h45\nSlides: R for Spatial Analysis\n\n\n1\nComputer tutorial\n14h00-16h00\nR for Spatial Analysis\n\n\n2\nLecture\n09h00-09h45\nSlides: Spatial Autocorrelation\n\n\n2\nComputer tutorial\n10h00-12h00\nSpatial Autocorrelation\n\n\n2\nLecture\n13h00-13h45\nSlides: Spatial Models\n\n\n2\nComputer tutorial\n14h00-16h00\nSpatial Models\n\n\n\n\n\n\nThis workbook is created using the Quarto publishing system. The workbook’s content is partially based on content from:\n\nThe GEOG0030: Geocomputation 2023-2024 workbook by Justin van Dijk\nThe Mapping and Modelling Geographic Data in R course by Richard Harris"
  },
  {
    "objectID": "00-index.html#welcome",
    "href": "00-index.html#welcome",
    "title": "SA-TIED Geospatial Workshop",
    "section": "",
    "text": "Welcome to the workbook for the SA-TIED Geospatial Workshop. Over the course of this two-day introductory workshop, you will be introduced to the R programming language, learn how to map socio-economic and demographic data, and gain an understanding of the ideas behind spatial models. We will explore the following topics:\n\nFundamentals of using R for data analysis with the tidyverse library\nCreating basic maps using R using the tmap library\nQuantifying the degree of spatial dependence in a dataset\nIncorporating space into statistical models"
  },
  {
    "objectID": "00-index.html#prerequisites",
    "href": "00-index.html#prerequisites",
    "title": "SA-TIED Geospatial Workshop",
    "section": "",
    "text": "While there are no specific prerequisites for this workshop, basic familiarity with R, Python or Stata do-files is recommended. You will require a computer with admin rights to install the necessary software."
  },
  {
    "objectID": "00-index.html#workshop-overview",
    "href": "00-index.html#workshop-overview",
    "title": "SA-TIED Geospatial Workshop",
    "section": "",
    "text": "The schedule of this workshop is as follows:\n\n\n\nDay\nType\nTime\nDetails\n\n\n\n\n1\nLecture\n09h00-09h45\nSlides: R for Data Analysis\n\n\n1\nComputer tutorial\n10h00-12h00\nR for Data Analysis\n\n\n1\nLecture\n13h00-13h45\nSlides: R for Spatial Analysis\n\n\n1\nComputer tutorial\n14h00-16h00\nR for Spatial Analysis\n\n\n2\nLecture\n09h00-09h45\nSlides: Spatial Autocorrelation\n\n\n2\nComputer tutorial\n10h00-12h00\nSpatial Autocorrelation\n\n\n2\nLecture\n13h00-13h45\nSlides: Spatial Models\n\n\n2\nComputer tutorial\n14h00-16h00\nSpatial Models"
  },
  {
    "objectID": "00-index.html#acknowledgements",
    "href": "00-index.html#acknowledgements",
    "title": "SA-TIED Geospatial Workshop",
    "section": "",
    "text": "This workbook is created using the Quarto publishing system. The workbook’s content is partially based on content from:\n\nThe GEOG0030: Geocomputation 2023-2024 workbook by Justin van Dijk\nThe Mapping and Modelling Geographic Data in R course by Richard Harris"
  },
  {
    "objectID": "01-getting-started.html",
    "href": "01-getting-started.html",
    "title": "1 R for Data Analysis",
    "section": "",
    "text": "R is a programming language originally designed for conducting statistical analysis and creating graphics. The major advantage of using R is that it is open source, can be used on any computer operating system, and is free for anyone to use and contribute to. Because of this, it has rapidly become the statistical language of choice for many academics and has a large user community with people constantly contributing new packages to carry out all manner of statistical, graphical, and importantly for us, geographical tasks.\nInstalling R takes a few relatively simple steps involving two pieces of software. First there is the R programme itself. Follow these steps to get it installed on your computer:\n\nNavigate in your browser to the download page: [Link]\nIf you use a Windows computer, click on Download R for Windows. Then click on base. Download and install R 4.4.x for Windows. If you use a Mac computer, click on Download R for macOS and download and install R-4.4.x.arm64.pkg for Apple silicon Macs and R-4.4.x.x86_64.pkg for older Intel-based Macs.\n\nThat is it! You now have successfully installed R onto your computer. To make working with the R language a little bit easier we also need to install something called an Integrated Development Environment (IDE). We will use RStudio Desktop:\n\nNavigate to the official webpage of RStudio: [Link]\nDownload and install RStudio Desktop on your computer (free version!)\n\nAfter this, start RStudio to see if the installation was successful and you should see something similar to what is shown in Figure 1.\n\n\n\n\n\nFigure 1: The RStudio interface.\n\n\n\n\nThe main windows that we will be using are:\n\n\n\n\n\n\n\nWindow\nPurpose\n\n\n\n\nConsole\nwhere we write one-off code such as installing packages\n\n\nFiles\nwhere we can see where our files are stored on our computer system\n\n\nEnvironment\nwhere our variables or objects are kept in memory\n\n\nPlots\nwhere the outputs of our graphs, charts and maps are shown\n\n\n\n\n\n\nNow we have installed R and RStudio, we need to customise R. Many useful R functions come in packages, these are free libraries of code written and made available by other R users. This includes packages specifically developed for data cleaning, data wrangling, visualisation, mapping, and spatial analysis. To save us some time, we will install all R packages that we will need for the workshop in one go. Start RStudio, and copy and paste the following code into the console window. You can execute the code by pressing the Return button on your keyboard. Depending on your computer’s specifications and the internet connection, this may take a short while.\n\n\n\nR code\n\n# install packages\ninstall.packages(c(\"tidyverse\", \"haven\", \"sf\", \"tmap\", \"spdep\"))\n\n\n\n\n\n\n\n\nFor Linux and macOS users who are new to working with spatial data in R, this installation of some of these libraries may fail since additional (non-R) libraries are required (which are automatically installed for Windows users). If this is the case, please refer to the information pages of the sf library for instructions.\n\n\n\nOnce you have installed the packages, we need to check whether we can in fact load them into R. Copy and paste the following code into the console, and execute by pressing Return on your keyboard again.\n\n\n\nR code\n\n# load packages\nlibrary(tidyverse)\nlibrary(haven)\nlibrary(sf)\nlibrary(tmap)\nlibrary(spdep)\n\n\nYou will see some information printed to your console but as long as you do not get any of the messages below, the installation was successful. If you do get any of the messages below it means that the package was not properly installed, so try to install the package in question again.\n\nError: package or namespace load failed for &lt;packagename&gt;\nError: package '&lt;packagename&gt;' could not be loaded\nError in library(&lt;packagename&gt;) : there is no package called '&lt;packagename&gt;'\n\n\n\n\n\n\n\nMany packages depend on other packages (so-called dependencies). It happens at times when you install a package it does not install all dependencies. If you encounter any of the above errors in reference to a package that you did not explicitly install, it is probably a missing dependency. Simply install the dependency by typing install.packages('&lt;dependencyname&gt;') and try loading all packages again.\n\n\n\n\n\n\nUnlike traditional statistical analysis software like Microsoft Excel or Stata, which often rely on point-and-click interfaces, R requires users to input commands to perform tasks such as loading datasets or fitting models. This command-based approach is typically done by writing scripts, which not only document your workflow but also allow for easy repetition of tasks.\n\n\n\n\n\n\nIf you are familiar with Stata’s do-file you will find that the approach to programming in R is comparable.\n\n\n\nWe will first start off with using to test out some of R’s in-built functionality by creating a few variables. In your console, let us go ahead and conduct some quick maths. At their most basic, all programming languages can be used like calculators.\n\n\n\n\n\n\nIn your RStudio console, you should see a prompt sign &gt; on the left hand side. This is where we can directly interact with R. Anything that appears as red in the command line means it is an error or a warning. If you just see a &gt; it means you can type in your next line, whereas a + means that you have not finished the previous line of code. As will become clear, + signs often appear if you do not close brackets or you did not properly finish your command in a way that R expected.\n\n\n\n\n\nType in 10 * 12 into the console and execute.\n\n\n\nR code\n\n# multiplication\n10 * 12\n\n\n[1] 120\n\n\nOnce you press return, you should see the answer of 120 returned below.\n\n\n\nRather than use raw or standalone numbers and values, we primarily want to use variables that store these values (or groups of them) under a memorable name for easy reference later. In R terminology this is called creating an object and this object becomes stored as a variable. The &lt;- symbol is used to assign the value to the variable name you have given. Let us create two variables to experiment with.\nType in ten &lt;- 10 into the console and execute.\n\n\n\nR code\n\n# store a variable\nten &lt;- 10\n\n\nYou will see nothing is returned in the console, but if you check your environment window it has now appeared as a new variable that contains the associated value.\nType in twelve &lt;- 12 into the console and execute.\n\n\n\nR code\n\n# store a variable\ntwelve &lt;- 12\n\n\nOnce again, you will see nothing returned to the console but do check your environment window for your variable. We have now stored two numbers into our environment and given them variable names for easy reference. R stores these objects as variables in your computer’s RAM memory so they can be processed quickly. Without saving your environment, these variables would be lost if you close R. Now we have our variables, we can go ahead and execute the same simple multiplication:\nType in ten * twelve into the console and execute.\n\n\n\nR code\n\n# using variables\nten * twelve\n\n\n[1] 120\n\n\nYou should see the output in the console of 120. Whilst this maths may look trivial, it is, in fact, extremely powerful as it shows how these variables can be treated in the same way as the values they contain.\nNext, type in ten * twelve * 8 into the console and execute.\n\n\n\nR code\n\n# using variables and values\nten * twelve * 8\n\n\n[1] 960\n\n\nYou should get an answer of 960. As you can see, we can mix variables with raw values without any problems. We can also store the output of variable calculations as a new variable.\nType output &lt;- ten * twelve * 8 into the console and execute.\n\n\n\nR code\n\n# store output\noutput &lt;- ten * twelve * 8\n\n\nBecause we are storing the output of our maths to a new variable, the answer is not returned to the screen.\n\n\n\nWe can ask our computer to return this output by simply typing it into the console. You should see we get the same value as the earlier equation.\n\n\n\nR code\n\n# return value\noutput\n\n\n[1] 960\n\n\n\n\n\nWe can also store variables of different data types, not just numbers but text as well.\nType in str_variable &lt;- \"Hello Pretoria\" into the console and execute.\n\n\n\nR code\n\n# store a variable\nstr_variable &lt;- \"Hello Pretoria\"\n\n\nWe have just stored our sentence made from a combination of characters. A variable that stores text is known as a string. A string is always denoted by the use of quotation marks (\"\" or '').\nType in str_variable into the console and execute.\n\n\n\nR code\n\n# return variable\nstr_variable\n\n\n[1] \"Hello Pretoria\"\n\n\nYou should see our entire sentence returned, enclosed in quotation marks (\"\").\n\n\n\nWe can also call a function on our variable. For example, we can also ask R to print our variable, which will give us the same output as accessing it directly via the console.\nType in print(str_variable) into the console and execute.\n\n\n\nR code\n\n# printing a variable\nprint(str_variable)\n\n\n[1] \"Hello Pretoria\"\n\n\nYou can type ?print into the console to find out more about the print() function.\n\n\n\nR code\n\n# open documentation of the print function\n?print\n\n\nThis can be used with any function to get access to their documentation which is essential to know how to use the function correctly and understand its output.\n\n\n\n\n\n\nIn many cases, a function will take more than one argument or parameter, so it is important to know what you need to provide the function with in order for it to work. For now, we are using functions that only need one required argument although most functions will also have several optional or default parameters.\n\n\n\n\n\n\nWithin the base R language, there are various functions that have been written to help us examine and find out information about our variables. For example, we can use the typeof() function to check what data type our variable is.\nType in typeof(str_variable) into the console and execute.\n\n\n\nR code\n\n# call the typeof() function\ntypeof(str_variable)\n\n\n[1] \"character\"\n\n\nYou should see the answer: character. As evident, our str_variable is a character data type. We can try testing this out on one of our earlier variables too.\nType in typeof(ten) into the console and execute.\n\n\n\nR code\n\n# call the typeof() function\ntypeof(ten)\n\n\n[1] \"double\"\n\n\nYou should see the answer: double. For high-level objects that involve more complex data structures, such as when we load a csv or .dta into R as a dataframe, we are also able to check what class our object is. Type in class(str_variable) into the console and execute.\n\n\n\nR code\n\n# call the class() function\nclass(str_variable)\n\n\n[1] \"character\"\n\n\nIn this case, you will get the same answer because in R both its class and type are the same: a character. In other programming languages, you might have had string returned instead, but this effectively means the same thing.\nType in class(ten) into the console and execute.\n\n\n\nR code\n\n# call the class() function\nclass(ten)\n\n\n[1] \"numeric\"\n\n\nIn this case, you will get a different answer because the class of this variable is numeric. This is because the class of numeric objects can contain either doubles (decimals) or integers (whole numbers). We can test this by asking whether our ten variable is an integer or not.\nType in is.integer(ten) into the console and execute.\n\n\n\nR code\n\nis.integer(ten)\n\n\n[1] FALSE\n\n\nYou should see we get the answer FALSE: as we know from our earlier typeof() function our variable ten is stored as a double and therefore cannot be an integer.\n\n\n\n\n\n\nWhilst knowing how to distinguish between different data types might not seem important now, the difference of a double versus an integer can quite easily lead to unexpected errors.\n\n\n\nWe can also ask how long our variable is. in this case, we will find out how many different sets of characters (strings) are stored in our variable, str_variable.\nType in length(str_variable) into the console and execute.\n\n\n\nR code\n\n# call the length() function\nlength(str_variable)\n\n\n[1] 1\n\n\nYou should get the answer 1 because we only have one set of characters. We can also ask how long each set of characters is within our variable, i.e. ask how long the string contained by our variable is.\nType in nchar(str_variable) into the console and execute.\n\n\n\nR code\n\n# call the nchar() function\nnchar(str_variable)\n\n\n[1] 14\n\n\nYou should get an answer of 31.\n\n\n\nVariables are not constricted to one value, but can be combined to create larger objects. Type in two_str_variable &lt;- c(\"This is our second variable\", \"It has two parts to it\") into the console and execute.\n\n\n\nR code\n\n# store a new variable\ntwo_str_variable &lt;- c(\"This is our second string variable\", \"It has two parts to it\")\n\n\nIn this piece of code, we have created a new variable using the c() function in R, that stands for combine values into a vector or list. We have provided that function with two sets of strings, using a comma to separate our two strings - all contained within the function’s brackets (()). Y\nLet us now try both our length() and nchar() on our new variable and see what the results are:\n\n\n\nR code\n\n# call the length() function\nlength(two_str_variable)\n\n\n[1] 2\n\n# call the nchar() function\nnchar(two_str_variable)\n\n[1] 34 22\n\n\nYou should notice that the length() function now returned a 2 and the nchar() function returned two values of 34 and 22.\n\n\n\n\n\n\nYou may have noticed that every line of code in the examples is accompanied by a comment explaining its purpose. Comments in R are created using the hash symbol: #. This symbol tells R to ignore the commented line when running the code. These comments are helpful for understanding your code when you revisit it later or share with others.\n\n\n\nIf we extend the concept of multi-value objects in two dimensions, we end up with a dataframe. A dataframe is the de-facto data structure for most tabular data. We will use functions from the tidyverse library, which is essentially a suite of packages, to load a data file and conduct some exploratory data analysis. Within the context of the tidyverse dataframes are referred to as tibbles. Some of the most important and useful functions, from the tidyr and dplyr packages, are:\n\n\n\n\n\n\n\n\nPackage\nFunction\nUse to\n\n\n\n\ndplyr\nselect()\nselect columns\n\n\ndplyr\nfilter()\nselect rows\n\n\ndplyr\nmutate()\ntransform or recode variables\n\n\ndplyr\nsummarise()\nsummarise data\n\n\ndplyr\ngroup_by()\ngroup data into subgroups for further processing\n\n\ntidyr\npivot_longer()\nconvert data from wide format to long format\n\n\ntidyr\npivot_wider()\nconvert long format dataset to wide format\n\n\n\n\n\n\n\n\n\nFor more information on the tidyverse have a look at www.tidyverse.org.\n\n\n\n\n\n\n\nIn RStudio, we can use scripts to build up our code that we can run repeatedly and save for future use. We can organise these scripts into RStduio projects.These projects keep all the files associated with an analysis together: input data, R scripts, analytical results, figures, etc. This means we can easily keep track of all data, input and output, whilst still creating standalone scripts for each bit of processing analysis we do. It also makes dealing with directories and filepaths much easier.\nNavigate to File -&gt; New Project -&gt; New Directory, and create a folder with the name GeoSpatial-Workshop24. Click on Create Project. You should now see your main window switch to this new project and if you check your files window, you should now see a new R Project called GeoSpatial-Workshop24.\n\n\n\n\n\n\nPlease ensure that folder names and file names do not contain spaces or special characters such as * . \" / \\ [ ] : ; | = , &lt; ? &gt; & $ # ! ' { } ( ). Different operating systems and programming languages deal differently with spaces and special characters and as such including these in your folder names and file names can cause many problems and unexpected errors. As an alternative to using white space you can use an underscore _ or hyphen - if you like.\n\n\n\n\n\n\nWith the basics covered, let us dive into loading a real dataset, performing data cleaning, and conducting some exploratory data analysis. We will work with a dataset that contains counts of the primary languages spoken in South African, sourced from the South African Census Community Profiles 2011 and made available through the DataFirst data service. You can download a copy of the file through the link below and save it in your project folder under data/attributes.\n\n\n\nFile\nType\nLink\n\n\n\n\nSA Census 2011 Language Table\n.dta\nDownload\n\n\n\nTo get started, let us create our first script. File -&gt; New File -&gt; R Script. Create a folder named scripts, and save your script as 01-language-analysis.r.\nWe will start by loading the libraries that we will need:\n\n\n\nR code\n\n# load libraries\nlibrary(tidyverse)\nlibrary(haven)\n\n\n\n\n\n\n\n\nIn RStudio, there are two primary ways to run a script: all at once or by executing individual lines or chunks of code. As a beginner, it is often beneficial to use the line-by-line approach, as it allows you to test your code interactively and catch errors early.\nTo run line-by-line:\n\nBy clicking: Highlight the line or chunk of code you want to run, then go to Code and select Run selected lines.\nBy key commands: Highlight the code, then press Ctl (or Cmd on Mac) + Return.\n\nTo run the whole script:\n\nBy clicking: In the scripting window, click Run in the top-right corner and choose Run All.\nBy key commands: Press Option + Ctrl (or Cmd) + R.\n\nIf a script gets stuck or you realise there is an error in your code, you may need to interrupt R. To do this, go to Session -&gt; Interrupt R. If the interruption doesn’t work, you might need to terminate and restart R.\n\n\n\n\n\nNext, we can load the language.dta file into R. Using functions from the haven library, R is capable to read a large range of different filetypes - Stata’s .dta file included.\n\n\n\nR code\n\n# load data\natt &lt;- read_dta(\"data/attributes/language.dta\")\n\n\n\n\n\n\n\n\nIf using a Windows machine, you may need to substitute your forward-slashes (/) with two backslashes (\\\\) whenever you are dealing with file paths.\n\n\n\nLet us have a look at the dataframe:\n\n\n\nR code\n\n# inspect columns, rows\nncol(att)\n\n\n[1] 28\n\nnrow(att)\n\n[1] 84908\n\n# inspect data\nhead(att)\n\n# A tibble: 6 × 28\n  sal_code   sp_code sp_name   mp_code mp_name mn_mdb_c mn_code mn_name dc_mdb_c\n     &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   \n1  1600001 160002001 Matzikam…  160002 Matzik… WC011        160 Matzik… DC1     \n2  1600002 160002001 Matzikam…  160002 Matzik… WC011        160 Matzik… DC1     \n3  1600003 160002001 Matzikam…  160002 Matzik… WC011        160 Matzik… DC1     \n4  1600004 160010001 Vredenda…  160010 Vreden… WC011        160 Matzik… DC1     \n5  1600005 160002001 Matzikam…  160002 Matzik… WC011        160 Matzik… DC1     \n6  1600006 160002001 Matzikam…  160002 Matzik… WC011        160 Matzik… DC1     \n# ℹ 19 more variables: dc_code &lt;dbl&gt;, dc_name &lt;chr&gt;, pr_code &lt;dbl&gt;,\n#   pr_name &lt;chr&gt;, lng_1 &lt;dbl&gt;, lng_2 &lt;dbl&gt;, lng_3 &lt;dbl&gt;, lng_4 &lt;dbl&gt;,\n#   lng_5 &lt;dbl&gt;, lng_6 &lt;dbl&gt;, lng_7 &lt;dbl&gt;, lng_8 &lt;dbl&gt;, lng_9 &lt;dbl&gt;,\n#   lng_10 &lt;dbl&gt;, lng_11 &lt;dbl&gt;, lng_12 &lt;dbl&gt;, lng_13 &lt;dbl&gt;, lng_14 &lt;dbl&gt;,\n#   lng_15 &lt;dbl&gt;\n\n# inspect column names\nnames(att)\n\n [1] \"sal_code\" \"sp_code\"  \"sp_name\"  \"mp_code\"  \"mp_name\"  \"mn_mdb_c\"\n [7] \"mn_code\"  \"mn_name\"  \"dc_mdb_c\" \"dc_code\" \n [ reached getOption(\"max.print\") -- omitted 18 entries ]\n\n\nTo access specific columns or rows in a dataframe, we can use indexing. Indexing refers to the numbering assigned to each element within a data structure, allowing us to precisely select and manipulate data.\nIn R, indexing begins at 1, meaning that the first element of any data structure is accessed with the index [1]. This is different from many other programming languages, such as Python or Java, where indexing typically starts at 0. For example, to access the first row of a dataframe, you would use dataframe[1, ], and to access the first column, you would use dataframe[, 1]. The comma separates the row and column indices, with the absence of a number indicating all rows or columns respectively.\n\n\n\nR code\n\n# index rows\natt[, 1]\n\n\n# A tibble: 84,908 × 1\n   sal_code\n      &lt;dbl&gt;\n 1  1600001\n 2  1600002\n 3  1600003\n 4  1600004\n 5  1600005\n 6  1600006\n 7  1600007\n 8  1600008\n 9  1600009\n10  1600010\n# ℹ 84,898 more rows\n\n# index columns\natt[1, ]\n\n# A tibble: 1 × 28\n  sal_code   sp_code sp_name   mp_code mp_name mn_mdb_c mn_code mn_name dc_mdb_c\n     &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   \n1  1600001 160002001 Matzikam…  160002 Matzik… WC011        160 Matzik… DC1     \n# ℹ 19 more variables: dc_code &lt;dbl&gt;, dc_name &lt;chr&gt;, pr_code &lt;dbl&gt;,\n#   pr_name &lt;chr&gt;, lng_1 &lt;dbl&gt;, lng_2 &lt;dbl&gt;, lng_3 &lt;dbl&gt;, lng_4 &lt;dbl&gt;,\n#   lng_5 &lt;dbl&gt;, lng_6 &lt;dbl&gt;, lng_7 &lt;dbl&gt;, lng_8 &lt;dbl&gt;, lng_9 &lt;dbl&gt;,\n#   lng_10 &lt;dbl&gt;, lng_11 &lt;dbl&gt;, lng_12 &lt;dbl&gt;, lng_13 &lt;dbl&gt;, lng_14 &lt;dbl&gt;,\n#   lng_15 &lt;dbl&gt;\n\n# specific value\natt[1, 1]\n\n# A tibble: 1 × 1\n  sal_code\n     &lt;dbl&gt;\n1  1600001\n\n\nAlternatively, you can access the data within individual columns by referring to their names using the $ operator. This allows you to easily extract and work with a specific column without needing to know its position in the dataframe. For example, if your dataframe is named dataframe and you want to access a column named age, you would use dataframe$age. This method is especially useful when your data has many columns or when the column positions may change, as it relies on the column names rather than their index numbers.\n\n\n\nNow that we have loaded and inspected our data, we can examine its distribution. We will focus on the column that contains the counts of individuals who speak isiXhosa as their primary language, aggregated by Small Area Layer—the most granular geographic level available in the 2011 Census. This data is stored in the lng_4 column of the dataframe.\n\n\n\nR code\n\n# mean\nmean(att$lng_4)\n\n\n[1] 95.99431\n\n# median\nmedian(att$lng_4)\n\n[1] 9\n\n# range\nrange(att$lng_4)\n\n[1]    0 6465\n\n# summary\nsummary(att$lng_4)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   0.00    0.00    9.00   95.99   72.00 6465.00 \n\n\nWe can also call some functions to quickly draw a boxplot, histogram, or scatterplot:\n\n\n\nR code\n\n# boxplot\nboxplot(att$lng_4, horizontal = TRUE)\n\n\n\n\n\nFigure 2: Quick boxplot.\n\n\n\n\n\n\n\nR code\n\n# histogram\nhist(att$lng_4, breaks = 50, xlab = \"isiXhosa\")\n\n\n\n\n\nFigure 3: Quick histogram.\n\n\n\n\n\n\n\nR code\n\n# bivariate plot\nplot(att$lng_4, att$lng_2, xlab = \"isiXhosa\", ylab = \"English\")\n\n\n\n\n\nFigure 4: Quick bivariate plot.\n\n\n\n\n\n\n\nThe dataset is quite extensive, containing counts for all 84,908 Small Area Layers. To make our analysis more manageable, let’s focus on a subset of the data, specifically zooming in on Cape Town. We can achieve this by filtering the data using the dc_name column, which corresponds to the District Municipality Name.\n\n\n\nR code\n\n# prepare data: filter out Cape Town\natt &lt;- att |&gt;\n    filter(dc_name == \"City of Cape Town\")\n\n\n\n\n\n\n\n\nThe code above uses a pipe function: |&gt;. The pipe operator allows you to pass the output of one function directly into the next, streamlining your code. While it might seem a bit confusing at first, you will find that it makes your code faster to write and easier to read. More importantly, it reduces the need to create multiple intermediate variables to store outputs.\n\n\n\nIn this case, we have overwritten our initial object, though this is not strictly necessary. Our object now contains a subset of the full language dataset that we initially loaded.\n\n\n\nR code\n\n# inspect data\nhead(att)\n\n\n# A tibble: 6 × 28\n  sal_code   sp_code sp_name   mp_code mp_name mn_mdb_c mn_code mn_name dc_mdb_c\n     &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   \n1  1990001 199014025 Paarden …  199014 Milner… CPT          199 City o… CPT     \n2  1990002 199016089 Mimosa     199016 Bellvi… CPT          199 City o… CPT     \n3  1990003 199041008 Signal H…  199041 Cape T… CPT          199 City o… CPT     \n4  1990004 199017021 Durbanvi…  199017 Durban… CPT          199 City o… CPT     \n5  1990005 199053012 Pine Hav…  199053 Simon'… CPT          199 City o… CPT     \n6  1990006 199030007 Guguleth…  199030 Gugule… CPT          199 City o… CPT     \n# ℹ 19 more variables: dc_code &lt;dbl&gt;, dc_name &lt;chr&gt;, pr_code &lt;dbl&gt;,\n#   pr_name &lt;chr&gt;, lng_1 &lt;dbl&gt;, lng_2 &lt;dbl&gt;, lng_3 &lt;dbl&gt;, lng_4 &lt;dbl&gt;,\n#   lng_5 &lt;dbl&gt;, lng_6 &lt;dbl&gt;, lng_7 &lt;dbl&gt;, lng_8 &lt;dbl&gt;, lng_9 &lt;dbl&gt;,\n#   lng_10 &lt;dbl&gt;, lng_11 &lt;dbl&gt;, lng_12 &lt;dbl&gt;, lng_13 &lt;dbl&gt;, lng_14 &lt;dbl&gt;,\n#   lng_15 &lt;dbl&gt;\n\n\nOur code appears to have worked successfully. The next thing that we probably want to do is normalise our data. A common challenge with spatial data is that the spatial units aren not always the same size — some Small Area Layers may have larger populations, while others have fewer residents. This makes it difficult to compare absolute counts fairly. To address this, we can sum the counts across all relevant columns to determine the total number of speakers in each area. Then, we can calculate the proportion of isiXhosa speakers within each Small Area Layer.\n\n\n\nR code\n\n# prepare data: sum across\natt &lt;- att |&gt;\n    rowwise() |&gt;\n    mutate(sal_pop = sum(across(starts_with(\"lng\")), na.rm = TRUE))\n\n# prepare data: calculate percentages\natt &lt;- att |&gt;\n    mutate(sal_prop_xhosa = lng_4/sal_pop)\n\n# inspect data\nhead(att)\n\n\n# A tibble: 6 × 30\n  sal_code   sp_code sp_name   mp_code mp_name mn_mdb_c mn_code mn_name dc_mdb_c\n     &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   \n1  1990001 199014025 Paarden …  199014 Milner… CPT          199 City o… CPT     \n2  1990002 199016089 Mimosa     199016 Bellvi… CPT          199 City o… CPT     \n3  1990003 199041008 Signal H…  199041 Cape T… CPT          199 City o… CPT     \n4  1990004 199017021 Durbanvi…  199017 Durban… CPT          199 City o… CPT     \n5  1990005 199053012 Pine Hav…  199053 Simon'… CPT          199 City o… CPT     \n6  1990006 199030007 Guguleth…  199030 Gugule… CPT          199 City o… CPT     \n# ℹ 21 more variables: dc_code &lt;dbl&gt;, dc_name &lt;chr&gt;, pr_code &lt;dbl&gt;,\n#   pr_name &lt;chr&gt;, lng_1 &lt;dbl&gt;, lng_2 &lt;dbl&gt;, lng_3 &lt;dbl&gt;, lng_4 &lt;dbl&gt;,\n#   lng_5 &lt;dbl&gt;, lng_6 &lt;dbl&gt;, lng_7 &lt;dbl&gt;, lng_8 &lt;dbl&gt;, lng_9 &lt;dbl&gt;,\n#   lng_10 &lt;dbl&gt;, lng_11 &lt;dbl&gt;, lng_12 &lt;dbl&gt;, lng_13 &lt;dbl&gt;, lng_14 &lt;dbl&gt;,\n#   lng_15 &lt;dbl&gt;, sal_pop &lt;dbl&gt;, sal_prop_xhosa &lt;dbl&gt;\n\n\nYou can further inspect the results using the View() function.\nWe now have the percentage of people who speak isiXhosa as their primary language for each Small Area Layer. To provide a more meaningful representation, we can aggregate the data by sub-places. This involves grouping our data by sp_code, which contains unique sub-place codes. We will then:\n\nSum the number of isiXhosa speakers within each sub-place and store this in a new variable.\nSum the total number of people within each sub-place and store this in another new variable.\nExtract the distinct values for each sub-place.\n\nBy using the pipe function again, we can chain these steps together efficiently as follows:\n\n\n\nR code\n\n# prepare data: aggregate small areas to sub places\natt &lt;- att |&gt;\n    group_by(sp_code) |&gt;\n    mutate(sp_pop = sum(sal_pop)) |&gt;\n    mutate(sp_xhosa = sum(lng_4)) |&gt;\n    ungroup() |&gt;\n    distinct(sp_code, sp_pop, sp_xhosa)\n\n# inspect data\nhead(att)\n\n\n# A tibble: 6 × 3\n    sp_code sp_pop sp_xhosa\n      &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;\n1 199014025     12        0\n2 199016089   1212        0\n3 199041008     12        0\n4 199017021   7893      105\n5 199053012      9        0\n6 199030007  55242    47385\n\n\nYou can further inspect the results using the View() function.\nWe can save this dataset so that we can easily load it the next time we want to work with this by writing it to a .csv file.\n\n\n\nR code\n\n# write data\nwrite_csv(x = att, file = \"data/attributes/language.csv\")\n\n\n\n\n\n\nThis concludes this session. Please try to complete the following tasks:\n\nCreate a histogram showing the distribution of the number of isiXhosa speakers in Cape Town, grouped by sub-place.\nCreate a boxplot of the proportion of isiXhosa-speakers in Cape Town, grouped by sub place.\n\nNext, use the link below to download another dataset sourced from the South African Census Community Profiles 2011 that contains information on internet access. Save the file in your project folder under data/attributes.\n\n\n\nFile\nType\nLink\n\n\n\n\nSA Census 2011 Internet Access Table\n.dta\nDownload\n\n\n\nUse this dataset to:\n\nCreate a histogram of the distribution of the number of people with internet access at home in the City of Johannesburg, grouped by sub-place.\nCreate a boxplot of the proportion of people with internet access at home in the City of Johannesburg, grouped by sub-place."
  },
  {
    "objectID": "01-getting-started.html#installation-of-r",
    "href": "01-getting-started.html#installation-of-r",
    "title": "1 R for Data Analysis",
    "section": "",
    "text": "R is a programming language originally designed for conducting statistical analysis and creating graphics. The major advantage of using R is that it is open source, can be used on any computer operating system, and is free for anyone to use and contribute to. Because of this, it has rapidly become the statistical language of choice for many academics and has a large user community with people constantly contributing new packages to carry out all manner of statistical, graphical, and importantly for us, geographical tasks.\nInstalling R takes a few relatively simple steps involving two pieces of software. First there is the R programme itself. Follow these steps to get it installed on your computer:\n\nNavigate in your browser to the download page: [Link]\nIf you use a Windows computer, click on Download R for Windows. Then click on base. Download and install R 4.4.x for Windows. If you use a Mac computer, click on Download R for macOS and download and install R-4.4.x.arm64.pkg for Apple silicon Macs and R-4.4.x.x86_64.pkg for older Intel-based Macs.\n\nThat is it! You now have successfully installed R onto your computer. To make working with the R language a little bit easier we also need to install something called an Integrated Development Environment (IDE). We will use RStudio Desktop:\n\nNavigate to the official webpage of RStudio: [Link]\nDownload and install RStudio Desktop on your computer (free version!)\n\nAfter this, start RStudio to see if the installation was successful and you should see something similar to what is shown in Figure 1.\n\n\n\n\n\nFigure 1: The RStudio interface.\n\n\n\n\nThe main windows that we will be using are:\n\n\n\n\n\n\n\nWindow\nPurpose\n\n\n\n\nConsole\nwhere we write one-off code such as installing packages\n\n\nFiles\nwhere we can see where our files are stored on our computer system\n\n\nEnvironment\nwhere our variables or objects are kept in memory\n\n\nPlots\nwhere the outputs of our graphs, charts and maps are shown"
  },
  {
    "objectID": "01-getting-started.html#customisation-of-r",
    "href": "01-getting-started.html#customisation-of-r",
    "title": "1 R for Data Analysis",
    "section": "",
    "text": "Now we have installed R and RStudio, we need to customise R. Many useful R functions come in packages, these are free libraries of code written and made available by other R users. This includes packages specifically developed for data cleaning, data wrangling, visualisation, mapping, and spatial analysis. To save us some time, we will install all R packages that we will need for the workshop in one go. Start RStudio, and copy and paste the following code into the console window. You can execute the code by pressing the Return button on your keyboard. Depending on your computer’s specifications and the internet connection, this may take a short while.\n\n\n\nR code\n\n# install packages\ninstall.packages(c(\"tidyverse\", \"haven\", \"sf\", \"tmap\", \"spdep\"))\n\n\n\n\n\n\n\n\nFor Linux and macOS users who are new to working with spatial data in R, this installation of some of these libraries may fail since additional (non-R) libraries are required (which are automatically installed for Windows users). If this is the case, please refer to the information pages of the sf library for instructions.\n\n\n\nOnce you have installed the packages, we need to check whether we can in fact load them into R. Copy and paste the following code into the console, and execute by pressing Return on your keyboard again.\n\n\n\nR code\n\n# load packages\nlibrary(tidyverse)\nlibrary(haven)\nlibrary(sf)\nlibrary(tmap)\nlibrary(spdep)\n\n\nYou will see some information printed to your console but as long as you do not get any of the messages below, the installation was successful. If you do get any of the messages below it means that the package was not properly installed, so try to install the package in question again.\n\nError: package or namespace load failed for &lt;packagename&gt;\nError: package '&lt;packagename&gt;' could not be loaded\nError in library(&lt;packagename&gt;) : there is no package called '&lt;packagename&gt;'\n\n\n\n\n\n\n\nMany packages depend on other packages (so-called dependencies). It happens at times when you install a package it does not install all dependencies. If you encounter any of the above errors in reference to a package that you did not explicitly install, it is probably a missing dependency. Simply install the dependency by typing install.packages('&lt;dependencyname&gt;') and try loading all packages again."
  },
  {
    "objectID": "01-getting-started.html#getting-started-with-r",
    "href": "01-getting-started.html#getting-started-with-r",
    "title": "1 R for Data Analysis",
    "section": "",
    "text": "Unlike traditional statistical analysis software like Microsoft Excel or Stata, which often rely on point-and-click interfaces, R requires users to input commands to perform tasks such as loading datasets or fitting models. This command-based approach is typically done by writing scripts, which not only document your workflow but also allow for easy repetition of tasks.\n\n\n\n\n\n\nIf you are familiar with Stata’s do-file you will find that the approach to programming in R is comparable.\n\n\n\nWe will first start off with using to test out some of R’s in-built functionality by creating a few variables. In your console, let us go ahead and conduct some quick maths. At their most basic, all programming languages can be used like calculators.\n\n\n\n\n\n\nIn your RStudio console, you should see a prompt sign &gt; on the left hand side. This is where we can directly interact with R. Anything that appears as red in the command line means it is an error or a warning. If you just see a &gt; it means you can type in your next line, whereas a + means that you have not finished the previous line of code. As will become clear, + signs often appear if you do not close brackets or you did not properly finish your command in a way that R expected.\n\n\n\n\n\nType in 10 * 12 into the console and execute.\n\n\n\nR code\n\n# multiplication\n10 * 12\n\n\n[1] 120\n\n\nOnce you press return, you should see the answer of 120 returned below.\n\n\n\nRather than use raw or standalone numbers and values, we primarily want to use variables that store these values (or groups of them) under a memorable name for easy reference later. In R terminology this is called creating an object and this object becomes stored as a variable. The &lt;- symbol is used to assign the value to the variable name you have given. Let us create two variables to experiment with.\nType in ten &lt;- 10 into the console and execute.\n\n\n\nR code\n\n# store a variable\nten &lt;- 10\n\n\nYou will see nothing is returned in the console, but if you check your environment window it has now appeared as a new variable that contains the associated value.\nType in twelve &lt;- 12 into the console and execute.\n\n\n\nR code\n\n# store a variable\ntwelve &lt;- 12\n\n\nOnce again, you will see nothing returned to the console but do check your environment window for your variable. We have now stored two numbers into our environment and given them variable names for easy reference. R stores these objects as variables in your computer’s RAM memory so they can be processed quickly. Without saving your environment, these variables would be lost if you close R. Now we have our variables, we can go ahead and execute the same simple multiplication:\nType in ten * twelve into the console and execute.\n\n\n\nR code\n\n# using variables\nten * twelve\n\n\n[1] 120\n\n\nYou should see the output in the console of 120. Whilst this maths may look trivial, it is, in fact, extremely powerful as it shows how these variables can be treated in the same way as the values they contain.\nNext, type in ten * twelve * 8 into the console and execute.\n\n\n\nR code\n\n# using variables and values\nten * twelve * 8\n\n\n[1] 960\n\n\nYou should get an answer of 960. As you can see, we can mix variables with raw values without any problems. We can also store the output of variable calculations as a new variable.\nType output &lt;- ten * twelve * 8 into the console and execute.\n\n\n\nR code\n\n# store output\noutput &lt;- ten * twelve * 8\n\n\nBecause we are storing the output of our maths to a new variable, the answer is not returned to the screen.\n\n\n\nWe can ask our computer to return this output by simply typing it into the console. You should see we get the same value as the earlier equation.\n\n\n\nR code\n\n# return value\noutput\n\n\n[1] 960\n\n\n\n\n\nWe can also store variables of different data types, not just numbers but text as well.\nType in str_variable &lt;- \"Hello Pretoria\" into the console and execute.\n\n\n\nR code\n\n# store a variable\nstr_variable &lt;- \"Hello Pretoria\"\n\n\nWe have just stored our sentence made from a combination of characters. A variable that stores text is known as a string. A string is always denoted by the use of quotation marks (\"\" or '').\nType in str_variable into the console and execute.\n\n\n\nR code\n\n# return variable\nstr_variable\n\n\n[1] \"Hello Pretoria\"\n\n\nYou should see our entire sentence returned, enclosed in quotation marks (\"\").\n\n\n\nWe can also call a function on our variable. For example, we can also ask R to print our variable, which will give us the same output as accessing it directly via the console.\nType in print(str_variable) into the console and execute.\n\n\n\nR code\n\n# printing a variable\nprint(str_variable)\n\n\n[1] \"Hello Pretoria\"\n\n\nYou can type ?print into the console to find out more about the print() function.\n\n\n\nR code\n\n# open documentation of the print function\n?print\n\n\nThis can be used with any function to get access to their documentation which is essential to know how to use the function correctly and understand its output.\n\n\n\n\n\n\nIn many cases, a function will take more than one argument or parameter, so it is important to know what you need to provide the function with in order for it to work. For now, we are using functions that only need one required argument although most functions will also have several optional or default parameters.\n\n\n\n\n\n\nWithin the base R language, there are various functions that have been written to help us examine and find out information about our variables. For example, we can use the typeof() function to check what data type our variable is.\nType in typeof(str_variable) into the console and execute.\n\n\n\nR code\n\n# call the typeof() function\ntypeof(str_variable)\n\n\n[1] \"character\"\n\n\nYou should see the answer: character. As evident, our str_variable is a character data type. We can try testing this out on one of our earlier variables too.\nType in typeof(ten) into the console and execute.\n\n\n\nR code\n\n# call the typeof() function\ntypeof(ten)\n\n\n[1] \"double\"\n\n\nYou should see the answer: double. For high-level objects that involve more complex data structures, such as when we load a csv or .dta into R as a dataframe, we are also able to check what class our object is. Type in class(str_variable) into the console and execute.\n\n\n\nR code\n\n# call the class() function\nclass(str_variable)\n\n\n[1] \"character\"\n\n\nIn this case, you will get the same answer because in R both its class and type are the same: a character. In other programming languages, you might have had string returned instead, but this effectively means the same thing.\nType in class(ten) into the console and execute.\n\n\n\nR code\n\n# call the class() function\nclass(ten)\n\n\n[1] \"numeric\"\n\n\nIn this case, you will get a different answer because the class of this variable is numeric. This is because the class of numeric objects can contain either doubles (decimals) or integers (whole numbers). We can test this by asking whether our ten variable is an integer or not.\nType in is.integer(ten) into the console and execute.\n\n\n\nR code\n\nis.integer(ten)\n\n\n[1] FALSE\n\n\nYou should see we get the answer FALSE: as we know from our earlier typeof() function our variable ten is stored as a double and therefore cannot be an integer.\n\n\n\n\n\n\nWhilst knowing how to distinguish between different data types might not seem important now, the difference of a double versus an integer can quite easily lead to unexpected errors.\n\n\n\nWe can also ask how long our variable is. in this case, we will find out how many different sets of characters (strings) are stored in our variable, str_variable.\nType in length(str_variable) into the console and execute.\n\n\n\nR code\n\n# call the length() function\nlength(str_variable)\n\n\n[1] 1\n\n\nYou should get the answer 1 because we only have one set of characters. We can also ask how long each set of characters is within our variable, i.e. ask how long the string contained by our variable is.\nType in nchar(str_variable) into the console and execute.\n\n\n\nR code\n\n# call the nchar() function\nnchar(str_variable)\n\n\n[1] 14\n\n\nYou should get an answer of 31.\n\n\n\nVariables are not constricted to one value, but can be combined to create larger objects. Type in two_str_variable &lt;- c(\"This is our second variable\", \"It has two parts to it\") into the console and execute.\n\n\n\nR code\n\n# store a new variable\ntwo_str_variable &lt;- c(\"This is our second string variable\", \"It has two parts to it\")\n\n\nIn this piece of code, we have created a new variable using the c() function in R, that stands for combine values into a vector or list. We have provided that function with two sets of strings, using a comma to separate our two strings - all contained within the function’s brackets (()). Y\nLet us now try both our length() and nchar() on our new variable and see what the results are:\n\n\n\nR code\n\n# call the length() function\nlength(two_str_variable)\n\n\n[1] 2\n\n# call the nchar() function\nnchar(two_str_variable)\n\n[1] 34 22\n\n\nYou should notice that the length() function now returned a 2 and the nchar() function returned two values of 34 and 22.\n\n\n\n\n\n\nYou may have noticed that every line of code in the examples is accompanied by a comment explaining its purpose. Comments in R are created using the hash symbol: #. This symbol tells R to ignore the commented line when running the code. These comments are helpful for understanding your code when you revisit it later or share with others.\n\n\n\nIf we extend the concept of multi-value objects in two dimensions, we end up with a dataframe. A dataframe is the de-facto data structure for most tabular data. We will use functions from the tidyverse library, which is essentially a suite of packages, to load a data file and conduct some exploratory data analysis. Within the context of the tidyverse dataframes are referred to as tibbles. Some of the most important and useful functions, from the tidyr and dplyr packages, are:\n\n\n\n\n\n\n\n\nPackage\nFunction\nUse to\n\n\n\n\ndplyr\nselect()\nselect columns\n\n\ndplyr\nfilter()\nselect rows\n\n\ndplyr\nmutate()\ntransform or recode variables\n\n\ndplyr\nsummarise()\nsummarise data\n\n\ndplyr\ngroup_by()\ngroup data into subgroups for further processing\n\n\ntidyr\npivot_longer()\nconvert data from wide format to long format\n\n\ntidyr\npivot_wider()\nconvert long format dataset to wide format\n\n\n\n\n\n\n\n\n\nFor more information on the tidyverse have a look at www.tidyverse.org."
  },
  {
    "objectID": "01-getting-started.html#rstudio-projects",
    "href": "01-getting-started.html#rstudio-projects",
    "title": "1 R for Data Analysis",
    "section": "",
    "text": "In RStudio, we can use scripts to build up our code that we can run repeatedly and save for future use. We can organise these scripts into RStduio projects.These projects keep all the files associated with an analysis together: input data, R scripts, analytical results, figures, etc. This means we can easily keep track of all data, input and output, whilst still creating standalone scripts for each bit of processing analysis we do. It also makes dealing with directories and filepaths much easier.\nNavigate to File -&gt; New Project -&gt; New Directory, and create a folder with the name GeoSpatial-Workshop24. Click on Create Project. You should now see your main window switch to this new project and if you check your files window, you should now see a new R Project called GeoSpatial-Workshop24.\n\n\n\n\n\n\nPlease ensure that folder names and file names do not contain spaces or special characters such as * . \" / \\ [ ] : ; | = , &lt; ? &gt; & $ # ! ' { } ( ). Different operating systems and programming languages deal differently with spaces and special characters and as such including these in your folder names and file names can cause many problems and unexpected errors. As an alternative to using white space you can use an underscore _ or hyphen - if you like."
  },
  {
    "objectID": "01-getting-started.html#bathetha-isixhosa",
    "href": "01-getting-started.html#bathetha-isixhosa",
    "title": "1 R for Data Analysis",
    "section": "",
    "text": "With the basics covered, let us dive into loading a real dataset, performing data cleaning, and conducting some exploratory data analysis. We will work with a dataset that contains counts of the primary languages spoken in South African, sourced from the South African Census Community Profiles 2011 and made available through the DataFirst data service. You can download a copy of the file through the link below and save it in your project folder under data/attributes.\n\n\n\nFile\nType\nLink\n\n\n\n\nSA Census 2011 Language Table\n.dta\nDownload\n\n\n\nTo get started, let us create our first script. File -&gt; New File -&gt; R Script. Create a folder named scripts, and save your script as 01-language-analysis.r.\nWe will start by loading the libraries that we will need:\n\n\n\nR code\n\n# load libraries\nlibrary(tidyverse)\nlibrary(haven)\n\n\n\n\n\n\n\n\nIn RStudio, there are two primary ways to run a script: all at once or by executing individual lines or chunks of code. As a beginner, it is often beneficial to use the line-by-line approach, as it allows you to test your code interactively and catch errors early.\nTo run line-by-line:\n\nBy clicking: Highlight the line or chunk of code you want to run, then go to Code and select Run selected lines.\nBy key commands: Highlight the code, then press Ctl (or Cmd on Mac) + Return.\n\nTo run the whole script:\n\nBy clicking: In the scripting window, click Run in the top-right corner and choose Run All.\nBy key commands: Press Option + Ctrl (or Cmd) + R.\n\nIf a script gets stuck or you realise there is an error in your code, you may need to interrupt R. To do this, go to Session -&gt; Interrupt R. If the interruption doesn’t work, you might need to terminate and restart R.\n\n\n\n\n\nNext, we can load the language.dta file into R. Using functions from the haven library, R is capable to read a large range of different filetypes - Stata’s .dta file included.\n\n\n\nR code\n\n# load data\natt &lt;- read_dta(\"data/attributes/language.dta\")\n\n\n\n\n\n\n\n\nIf using a Windows machine, you may need to substitute your forward-slashes (/) with two backslashes (\\\\) whenever you are dealing with file paths.\n\n\n\nLet us have a look at the dataframe:\n\n\n\nR code\n\n# inspect columns, rows\nncol(att)\n\n\n[1] 28\n\nnrow(att)\n\n[1] 84908\n\n# inspect data\nhead(att)\n\n# A tibble: 6 × 28\n  sal_code   sp_code sp_name   mp_code mp_name mn_mdb_c mn_code mn_name dc_mdb_c\n     &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   \n1  1600001 160002001 Matzikam…  160002 Matzik… WC011        160 Matzik… DC1     \n2  1600002 160002001 Matzikam…  160002 Matzik… WC011        160 Matzik… DC1     \n3  1600003 160002001 Matzikam…  160002 Matzik… WC011        160 Matzik… DC1     \n4  1600004 160010001 Vredenda…  160010 Vreden… WC011        160 Matzik… DC1     \n5  1600005 160002001 Matzikam…  160002 Matzik… WC011        160 Matzik… DC1     \n6  1600006 160002001 Matzikam…  160002 Matzik… WC011        160 Matzik… DC1     \n# ℹ 19 more variables: dc_code &lt;dbl&gt;, dc_name &lt;chr&gt;, pr_code &lt;dbl&gt;,\n#   pr_name &lt;chr&gt;, lng_1 &lt;dbl&gt;, lng_2 &lt;dbl&gt;, lng_3 &lt;dbl&gt;, lng_4 &lt;dbl&gt;,\n#   lng_5 &lt;dbl&gt;, lng_6 &lt;dbl&gt;, lng_7 &lt;dbl&gt;, lng_8 &lt;dbl&gt;, lng_9 &lt;dbl&gt;,\n#   lng_10 &lt;dbl&gt;, lng_11 &lt;dbl&gt;, lng_12 &lt;dbl&gt;, lng_13 &lt;dbl&gt;, lng_14 &lt;dbl&gt;,\n#   lng_15 &lt;dbl&gt;\n\n# inspect column names\nnames(att)\n\n [1] \"sal_code\" \"sp_code\"  \"sp_name\"  \"mp_code\"  \"mp_name\"  \"mn_mdb_c\"\n [7] \"mn_code\"  \"mn_name\"  \"dc_mdb_c\" \"dc_code\" \n [ reached getOption(\"max.print\") -- omitted 18 entries ]\n\n\nTo access specific columns or rows in a dataframe, we can use indexing. Indexing refers to the numbering assigned to each element within a data structure, allowing us to precisely select and manipulate data.\nIn R, indexing begins at 1, meaning that the first element of any data structure is accessed with the index [1]. This is different from many other programming languages, such as Python or Java, where indexing typically starts at 0. For example, to access the first row of a dataframe, you would use dataframe[1, ], and to access the first column, you would use dataframe[, 1]. The comma separates the row and column indices, with the absence of a number indicating all rows or columns respectively.\n\n\n\nR code\n\n# index rows\natt[, 1]\n\n\n# A tibble: 84,908 × 1\n   sal_code\n      &lt;dbl&gt;\n 1  1600001\n 2  1600002\n 3  1600003\n 4  1600004\n 5  1600005\n 6  1600006\n 7  1600007\n 8  1600008\n 9  1600009\n10  1600010\n# ℹ 84,898 more rows\n\n# index columns\natt[1, ]\n\n# A tibble: 1 × 28\n  sal_code   sp_code sp_name   mp_code mp_name mn_mdb_c mn_code mn_name dc_mdb_c\n     &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   \n1  1600001 160002001 Matzikam…  160002 Matzik… WC011        160 Matzik… DC1     \n# ℹ 19 more variables: dc_code &lt;dbl&gt;, dc_name &lt;chr&gt;, pr_code &lt;dbl&gt;,\n#   pr_name &lt;chr&gt;, lng_1 &lt;dbl&gt;, lng_2 &lt;dbl&gt;, lng_3 &lt;dbl&gt;, lng_4 &lt;dbl&gt;,\n#   lng_5 &lt;dbl&gt;, lng_6 &lt;dbl&gt;, lng_7 &lt;dbl&gt;, lng_8 &lt;dbl&gt;, lng_9 &lt;dbl&gt;,\n#   lng_10 &lt;dbl&gt;, lng_11 &lt;dbl&gt;, lng_12 &lt;dbl&gt;, lng_13 &lt;dbl&gt;, lng_14 &lt;dbl&gt;,\n#   lng_15 &lt;dbl&gt;\n\n# specific value\natt[1, 1]\n\n# A tibble: 1 × 1\n  sal_code\n     &lt;dbl&gt;\n1  1600001\n\n\nAlternatively, you can access the data within individual columns by referring to their names using the $ operator. This allows you to easily extract and work with a specific column without needing to know its position in the dataframe. For example, if your dataframe is named dataframe and you want to access a column named age, you would use dataframe$age. This method is especially useful when your data has many columns or when the column positions may change, as it relies on the column names rather than their index numbers.\n\n\n\nNow that we have loaded and inspected our data, we can examine its distribution. We will focus on the column that contains the counts of individuals who speak isiXhosa as their primary language, aggregated by Small Area Layer—the most granular geographic level available in the 2011 Census. This data is stored in the lng_4 column of the dataframe.\n\n\n\nR code\n\n# mean\nmean(att$lng_4)\n\n\n[1] 95.99431\n\n# median\nmedian(att$lng_4)\n\n[1] 9\n\n# range\nrange(att$lng_4)\n\n[1]    0 6465\n\n# summary\nsummary(att$lng_4)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   0.00    0.00    9.00   95.99   72.00 6465.00 \n\n\nWe can also call some functions to quickly draw a boxplot, histogram, or scatterplot:\n\n\n\nR code\n\n# boxplot\nboxplot(att$lng_4, horizontal = TRUE)\n\n\n\n\n\nFigure 2: Quick boxplot.\n\n\n\n\n\n\n\nR code\n\n# histogram\nhist(att$lng_4, breaks = 50, xlab = \"isiXhosa\")\n\n\n\n\n\nFigure 3: Quick histogram.\n\n\n\n\n\n\n\nR code\n\n# bivariate plot\nplot(att$lng_4, att$lng_2, xlab = \"isiXhosa\", ylab = \"English\")\n\n\n\n\n\nFigure 4: Quick bivariate plot.\n\n\n\n\n\n\n\nThe dataset is quite extensive, containing counts for all 84,908 Small Area Layers. To make our analysis more manageable, let’s focus on a subset of the data, specifically zooming in on Cape Town. We can achieve this by filtering the data using the dc_name column, which corresponds to the District Municipality Name.\n\n\n\nR code\n\n# prepare data: filter out Cape Town\natt &lt;- att |&gt;\n    filter(dc_name == \"City of Cape Town\")\n\n\n\n\n\n\n\n\nThe code above uses a pipe function: |&gt;. The pipe operator allows you to pass the output of one function directly into the next, streamlining your code. While it might seem a bit confusing at first, you will find that it makes your code faster to write and easier to read. More importantly, it reduces the need to create multiple intermediate variables to store outputs.\n\n\n\nIn this case, we have overwritten our initial object, though this is not strictly necessary. Our object now contains a subset of the full language dataset that we initially loaded.\n\n\n\nR code\n\n# inspect data\nhead(att)\n\n\n# A tibble: 6 × 28\n  sal_code   sp_code sp_name   mp_code mp_name mn_mdb_c mn_code mn_name dc_mdb_c\n     &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   \n1  1990001 199014025 Paarden …  199014 Milner… CPT          199 City o… CPT     \n2  1990002 199016089 Mimosa     199016 Bellvi… CPT          199 City o… CPT     \n3  1990003 199041008 Signal H…  199041 Cape T… CPT          199 City o… CPT     \n4  1990004 199017021 Durbanvi…  199017 Durban… CPT          199 City o… CPT     \n5  1990005 199053012 Pine Hav…  199053 Simon'… CPT          199 City o… CPT     \n6  1990006 199030007 Guguleth…  199030 Gugule… CPT          199 City o… CPT     \n# ℹ 19 more variables: dc_code &lt;dbl&gt;, dc_name &lt;chr&gt;, pr_code &lt;dbl&gt;,\n#   pr_name &lt;chr&gt;, lng_1 &lt;dbl&gt;, lng_2 &lt;dbl&gt;, lng_3 &lt;dbl&gt;, lng_4 &lt;dbl&gt;,\n#   lng_5 &lt;dbl&gt;, lng_6 &lt;dbl&gt;, lng_7 &lt;dbl&gt;, lng_8 &lt;dbl&gt;, lng_9 &lt;dbl&gt;,\n#   lng_10 &lt;dbl&gt;, lng_11 &lt;dbl&gt;, lng_12 &lt;dbl&gt;, lng_13 &lt;dbl&gt;, lng_14 &lt;dbl&gt;,\n#   lng_15 &lt;dbl&gt;\n\n\nOur code appears to have worked successfully. The next thing that we probably want to do is normalise our data. A common challenge with spatial data is that the spatial units aren not always the same size — some Small Area Layers may have larger populations, while others have fewer residents. This makes it difficult to compare absolute counts fairly. To address this, we can sum the counts across all relevant columns to determine the total number of speakers in each area. Then, we can calculate the proportion of isiXhosa speakers within each Small Area Layer.\n\n\n\nR code\n\n# prepare data: sum across\natt &lt;- att |&gt;\n    rowwise() |&gt;\n    mutate(sal_pop = sum(across(starts_with(\"lng\")), na.rm = TRUE))\n\n# prepare data: calculate percentages\natt &lt;- att |&gt;\n    mutate(sal_prop_xhosa = lng_4/sal_pop)\n\n# inspect data\nhead(att)\n\n\n# A tibble: 6 × 30\n  sal_code   sp_code sp_name   mp_code mp_name mn_mdb_c mn_code mn_name dc_mdb_c\n     &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;      &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   \n1  1990001 199014025 Paarden …  199014 Milner… CPT          199 City o… CPT     \n2  1990002 199016089 Mimosa     199016 Bellvi… CPT          199 City o… CPT     \n3  1990003 199041008 Signal H…  199041 Cape T… CPT          199 City o… CPT     \n4  1990004 199017021 Durbanvi…  199017 Durban… CPT          199 City o… CPT     \n5  1990005 199053012 Pine Hav…  199053 Simon'… CPT          199 City o… CPT     \n6  1990006 199030007 Guguleth…  199030 Gugule… CPT          199 City o… CPT     \n# ℹ 21 more variables: dc_code &lt;dbl&gt;, dc_name &lt;chr&gt;, pr_code &lt;dbl&gt;,\n#   pr_name &lt;chr&gt;, lng_1 &lt;dbl&gt;, lng_2 &lt;dbl&gt;, lng_3 &lt;dbl&gt;, lng_4 &lt;dbl&gt;,\n#   lng_5 &lt;dbl&gt;, lng_6 &lt;dbl&gt;, lng_7 &lt;dbl&gt;, lng_8 &lt;dbl&gt;, lng_9 &lt;dbl&gt;,\n#   lng_10 &lt;dbl&gt;, lng_11 &lt;dbl&gt;, lng_12 &lt;dbl&gt;, lng_13 &lt;dbl&gt;, lng_14 &lt;dbl&gt;,\n#   lng_15 &lt;dbl&gt;, sal_pop &lt;dbl&gt;, sal_prop_xhosa &lt;dbl&gt;\n\n\nYou can further inspect the results using the View() function.\nWe now have the percentage of people who speak isiXhosa as their primary language for each Small Area Layer. To provide a more meaningful representation, we can aggregate the data by sub-places. This involves grouping our data by sp_code, which contains unique sub-place codes. We will then:\n\nSum the number of isiXhosa speakers within each sub-place and store this in a new variable.\nSum the total number of people within each sub-place and store this in another new variable.\nExtract the distinct values for each sub-place.\n\nBy using the pipe function again, we can chain these steps together efficiently as follows:\n\n\n\nR code\n\n# prepare data: aggregate small areas to sub places\natt &lt;- att |&gt;\n    group_by(sp_code) |&gt;\n    mutate(sp_pop = sum(sal_pop)) |&gt;\n    mutate(sp_xhosa = sum(lng_4)) |&gt;\n    ungroup() |&gt;\n    distinct(sp_code, sp_pop, sp_xhosa)\n\n# inspect data\nhead(att)\n\n\n# A tibble: 6 × 3\n    sp_code sp_pop sp_xhosa\n      &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;\n1 199014025     12        0\n2 199016089   1212        0\n3 199041008     12        0\n4 199017021   7893      105\n5 199053012      9        0\n6 199030007  55242    47385\n\n\nYou can further inspect the results using the View() function.\nWe can save this dataset so that we can easily load it the next time we want to work with this by writing it to a .csv file.\n\n\n\nR code\n\n# write data\nwrite_csv(x = att, file = \"data/attributes/language.csv\")"
  },
  {
    "objectID": "01-getting-started.html#assignment",
    "href": "01-getting-started.html#assignment",
    "title": "1 R for Data Analysis",
    "section": "",
    "text": "This concludes this session. Please try to complete the following tasks:\n\nCreate a histogram showing the distribution of the number of isiXhosa speakers in Cape Town, grouped by sub-place.\nCreate a boxplot of the proportion of isiXhosa-speakers in Cape Town, grouped by sub place.\n\nNext, use the link below to download another dataset sourced from the South African Census Community Profiles 2011 that contains information on internet access. Save the file in your project folder under data/attributes.\n\n\n\nFile\nType\nLink\n\n\n\n\nSA Census 2011 Internet Access Table\n.dta\nDownload\n\n\n\nUse this dataset to:\n\nCreate a histogram of the distribution of the number of people with internet access at home in the City of Johannesburg, grouped by sub-place.\nCreate a boxplot of the proportion of people with internet access at home in the City of Johannesburg, grouped by sub-place."
  },
  {
    "objectID": "02-mapping-data.html",
    "href": "02-mapping-data.html",
    "title": "1 R for Spatial Analysis",
    "section": "",
    "text": "1 R for Spatial Analysis"
  },
  {
    "objectID": "03-spatial-autocorrelation.html",
    "href": "03-spatial-autocorrelation.html",
    "title": "1 Spatial Autocorrelation",
    "section": "",
    "text": "1 Spatial Autocorrelation"
  },
  {
    "objectID": "04-spatial-models.html",
    "href": "04-spatial-models.html",
    "title": "1 Spatial Models",
    "section": "",
    "text": "1 Spatial Models"
  }
]
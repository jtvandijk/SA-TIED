# Spatial Autocorrelation

## Loading spatial data
Start your `Geospatial-Workshop24` project and open a new script. Save this as `03-autocorrelation.r`. We will start again by loading the libraries that we will need for:

```{r}
#| label: 03-load-libraries
#| classes: styled-output
#| echo: True
#| eval: True
#| output: False
#| tidy: True
#| filename: "R code"
# load libraries
library(tidyverse)
library(sf)
library(tmap)
library(spdep)
```


```{r}
#| label: 03-tmap-settings
#| classes: styled-output
#| echo: False
#| warning: False
#| message: False
#| eval: True
# ensure tmap is set to plot
tmap_mode("plot")
```

```{r}
#| label: 03-maxprint
#| echo: False
#| eval: True
options(max.print=1000)
``` 

In this session, we will be looking at education, focusing on the number of people with no schooling at the municipal level, as aggregated from the [South African Census Community Profiles 2011](https://www.statssa.gov.za/?page_id=3839). Along with this dataset, we also have access to a `GeoPackage` that contains the spatial boundaries of these municipalities. You can download both files below and save them in your project folder under `data/attributes` and `data/spatial`, respectively.

| File                                 | Type   | Link |
| :------                              | :------| :------ |
| SA Census 2011 No Schooling Variable          | `csv` | [Download](https://github.com/jtvandijk/SA-TIED/tree/master/data/attributes/sa-no-schooling.csv) |
| SA Municipalities                    | `GeoPackage`  | [Download](https://github.com/jtvandijk/SA-TIED/tree/master/data/spatial/municipality-south-africa-2013.gpkg) |

Now, we can load both files into memory:
```{r}
#| label: 03-load-gpkg-csv
#| classes: styled-output
#| echo: True
#| eval: True
#| tidy: True
#| cache: True
#| filename: "R code"
# load spatial data, transform projection
sa_municipality <- st_read('data/spatial/municipality-south-africa-2013.gpkg')

# load attribute data
sa_no_schooling <- read_csv('data/attributes/sa-no-schooling.csv')
``` 

::: {.callout-note}
You can further inspect the results using the `View()` function. 
:::

## Spatial dependency
With this dataset, we are interested in analysing the proportion of people without schooling across the country and visualising this information on a map. Let us start by preparing the data for mapping:

```{r}
#| label: 03-join-data
#| classes: styled-output
#| echo: True
#| eval: True
#| tidy: False
#| cache: True
#| filename: "R code"
# calculate proportions
sa_no_schooling <- sa_no_schooling |>
  mutate(mn_prop_no_schooling = mn_no_school / mn_pop)

# join attribute data onto spatial data
sa_municipality <- sa_municipality |> 
  left_join(sa_no_schooling, by = c("mn_code" = "mn_code"))
``` 

We can now create a simple map:

```{r tidy='styler'} 
#| label: fig-03-choro-1
#| fig-cap: Proportions of people having no schooling by municipality.
#| echo: True
#| eval: True
#| cache: True
#| filename: "R code"
# shape, polygons
tm_shape(sa_municipality) +
  # specify column, classes
  tm_polygons(
              col = "mn_prop_no_schooling", 
              n = 5, 
              style = "jenks"
  ) +
  
  # no legend
  tm_layout(
    legend.show = FALSE
  )
``` 

Looking at the map, the geographical patterning of the percentage of the population that did does not have any schooling appears to be neither random nor uniform, with a tendency for similar values to be found in closely located municipalities. Let us compare our map to a map with the same values which have been randomly permutated:

```{r tidy='styler'} 
#| label: fig-03-choro-2
#| fig-cap: Proportions of people having no schooling by municipality with randomly permutated values.
#| echo: True
#| eval: True
#| cache: True
#| filename: "R code"

# random permutation
sa_municipality <- sa_municipality |>
  mutate(mn_prop_no_schooling_random = sample(sa_municipality$mn_prop_no_schooling, replace = FALSE))

# shape, polygons
tm_shape(sa_municipality) +
  # specify column, classes
  tm_polygons(
              col = "mn_prop_no_schooling_random", 
              n = 5, 
              style = "jenks"
  ) +
  
  # no legend
  tm_layout(
    legend.show = FALSE
  )
``` 

Looking at @fig-03-choro-2, even with the values being randomly permuted, certain patterns seem to emerge. This observation raises an important question: to what extent are the patterns that we see in the actual data actually present? A widely used method to quantify the similarity between neighbouring locations is by calculating Moran’s I statistic. This measure assesses spatial autocorrelation, indicating the degree to which values of a variable cluster spatially — either through similar (positive spatial autocorrelation) or contrasting values (negative spatial autocorrelation).

Underlying our  Moran's I test is the concept of a **spatial lag**. A spatial lag refers to a concept in spatial analysis where the value of a variable at a given location is influenced by the values of the same variable at neighboring locations. Essentially, it captures the idea that observations in close proximity are likely to be correlated, meaning that what happens in one area can 'lag' into or affect nearby areas. The Moran's I statistic tries to capture the relationship between a value and its spatial lag. An Ordinary Least Squares (OLS) regression is applied, after both variables have been transformed to [z-scores](https://en.wikipedia.org/wiki/Standard_score), to fit the data and produce a slope, which determines the Moran’s I statistic.

```{r}
#| label: fig-moran-plot
#| echo: False 
#| fig-cap: "Scatter plot of spatially lagged income (neighboring income) versus each areas income. Source: [Manuel Gimond](https://mgimond.github.io/Spatial/spatial-autocorrelation.html)."
knitr::include_graphics('images/w03/moran-scatter.png')
```

To calculate a $p$-value for our Moran’s I model, the spatial lag model is run multiple times using a random distribution of neighbouring values. This generates different slopes representing various ways our data could be distributed under the assumption of randomness. The outcome of this process is a sampling distribution of Moran’s I values that supports the null hypothesis, suggesting our data is randomly distributed. We then compare our observed slope with the distribution of these random slopes to determine whether our slope falls within the typical range or is an outlier.

```{r}
#| label: fig-moran-plot-sig
#| echo: False 
#| fig-cap: "Determining significance using a Monte Carlo simulation. Source: [Manuel Gimond](https://mgimond.github.io/Spatial/spatial-autocorrelation.html)."
knitr::include_graphics('images/w03/mc-sim.png')
```

If our slope is an outlier, i.e. it is not a value we would expect if the data were randomly distributed, we can be more confident that the slope reflects significant clustering in our data. We can derive a *pseudo-*$p$ value from these simulation results:

$$
\frac{N_{extreme} + 1}{N + 1}
$$

Where ${N_{extreme}}$ is the number of simulated Moran's I values that were more extreme that our observed statistic and ${N}$ is the total number of simulations. In the example above shown in @fig-moran-plot-sig, only 1 out the 199 simulations was more extreme than the observed local Moran's I statistic. Therefore ${N_{extreme}}$ = 1 , so $p$ is equal to $(1+1) / (199 + 1) = 0.01$. This means that there is a one percent probability that we would be wrong in rejecting the null hypothesis.

## Defining neighbours
If the purpose of a Moran’s I test is to quantify how similar places are to their neighbours, the first step is to define what constitutes a **neighbour.** This definition is not necessarily straightforward, because 'neighbouring' observations can be determined in various ways, based on either geometry or proximity. The most common methods include:

- **Contiguity**: Spatial units are considered neighbours if their polygon boundaries touch.
- **Fixed Distance**: Spatial units are considered neighbours if they fall within a specified distance.
- **(K) Nearest Neighbours**: Spatial units are considered neighbours if they are among the closest neighbours.

To capture this information, we need to formalise the spatial relationships within our data by constructing a spatial weights matrix ($W_{ij}$). This matrix defines which units are neighbours based on our chosen criteria.

::: {.callout-note}
In the following example, neighbours are defined as places that share a border (i.e., they are contiguous). Currently, it is sufficient for them to meet at a single point — so if two places are triangular, touching corners would count them as neighbours. If, however, you require them to share an edge, rather than just a corner, you can modify the default argument by setting `queen = FALSE`.
:::

```{r}
#| label: 03-nb-queen
#| classes: styled-output
#| echo: True
#| eval: True
#| tidy: True
#| cache: True
#| filename: "R code"
# create neighbourlist
sa_mn_nb <- poly2nb(sa_municipality, queen = TRUE)

# inspect
summary(sa_mn_nb)
``` 
The `neighbour list` object is a [sparse matrix](https://en.wikipedia.org/wiki/Sparse_matrix) that lists the neighboring polygons for each municipality. This matrix represents the spatial relationships between municipalities, where each entry indicates which polygons share boundaries. These neighborhood relationships can be visualized as a graph by extracting the coordinate points of the centroids of the polygons representing each municipality:

::: {.callout-warning}
Regardless of the neighborhood definition you choose, it is important to verify the results, particularly when using contiguity-based approaches. If your spatial file has issues such as polygons that appear adjacent but do not actually share a border, your results may be inaccurate. You could increase the default value of the `snap` distance parameter in the `poly2nb` function to include these polygons only seperated by small gaps.
:::

```{r}
#| label: fig-nb-plot
#| fig-cap: Neighbourhood graph using queen contiguity.
#| classes: styled-output
#| echo: True
#| eval: True
#| tidy: True
#| cache: True
#| filename: "R code"
# extract centroids from polygons
sa_mn_cent <- st_centroid(sa_municipality, of_largest_polygon = TRUE)

# plot graph
par(mai = c(0,0,0,0))
plot(st_geometry(sa_municipality), border = '#cccccc')
plot(sa_mn_nb, st_geometry(sa_mn_cent), add = T)
``` 
## Defining weights
The neighbourhood list simply identifies which areas are neighbours, but spatial weights take this a step further by assigning a weight to each neighbourhood connection. This is important because not all polygons have the same number of neighbours. To ensure that our spatially lagged values are comparable across neighbourhoods of different sizes, standardisation is required. The code below uses `style = 'W'` to row-standardise the values: if a municipality has five neighbours, the value of the spatially lagged variable will be the average of that variable across those five neighbours, with each neighbour receiving equal weight.

```{r}
#| label: 03-nb-weights
#| classes: styled-output
#| echo: True
#| eval: True
#| tidy: True
#| cache: True
#| filename: "R code"
# create spatial weights matrix
sa_mn_nb_weights <- sa_mn_nb |>
    nb2listw(style = "W")

# inspect - neigbhours of polygon '10'
sa_mn_nb_weights$neighbours[[10]]

# inspect - weights of neighbours of polygon '10'
sa_mn_nb_weights$weights[[10]]
``` 

:::{.callout-note}
Not all places have neighbours. Islands, by definition, will not be considered as neighbours using a contiguity approach. If you attempt to create spatial weights using the `nb2listw()` function with a neighbourhood list that includes places without neighbours, you will encounter an error message. Potential solutions include using a different neighbourhood definition (e.g. $k$-nearest neighbours) or manually editing the neighbourhood file if you wish to include these polygons. Alternatively, you can leave it as is but must specify the argument `zero.policy = TRUE` in `nb2listw()` to allow for empty sets.
:::


